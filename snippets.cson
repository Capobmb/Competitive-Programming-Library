# Your snippets
#
# Pulsar snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     'prefix': 'log'
#     'body': 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Pulsar Launch Manual:
# https://pulsar-edit.dev/docs/launch-manual/sections/using-pulsar/#configuring-with-cson

'.source.cpp':
  'ini':
    'prefix':'ini'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      $1
    }
    """

  'ini2':
    'prefix':'ini2'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    void solve(){
      $1
    }

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      ll t;
      cin>>t;
      while(t--){
        solve();
      }
    }
    """

  'inib':
    'prefix':'inib'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    bool solve(){
      $1
    }

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      ll t;
      cin>>t;
      while(t--){
        cout << (solve() ? "Yes" : "No") << "\\\\n";
      }
    }
    """

  'ini0':
    'prefix':'ini0'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint1000000007;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      $1
    }
    """

  'ini9':
    'prefix':'ini9'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint998244353;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      $1
    }
    """

  'ini_arbitrary':
    'prefix':'ini_arbitrary'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(0);
      $1
      modint::set_mod();
    }
    """

  'atcoder':
    'prefix':'atcoder'
    'body':"""
    #include<atcoder/${1:all}>
    using namespace atcoder;
    """

  'main':
    'prefix':'main'
    'body':"""
    int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      $1
    }
    """

  ';':
    'prefix':'l'
    'body':';'

  'll':
    'prefix':'ll'
    'body':'ll $1'

  'double':
    'prefix':'db'
    'body':'long double $1'

  'string':
    'prefix':'string'
    'body':'string $1'

  'str':
    'prefix':'str'
    'body':'string $1'

  'char':
    'prefix':'char'
    'body':'char $1'

  'bool':
    'prefix':'bl'
    'body':'bool $1'

  'mint':
    'prefix':'mint'
    'body':'mint $1'

  'cin':
    'prefix':'cin'
    'body':'cin>>$1'

  'in1':
    'prefix':'in1'
    'body':"""
    ${1:ll} $2;
    cin>>$2;$3
    """

  'in2':
    'prefix':'in2'
    'body':"""
    ${1:ll} $2,$3;
    cin>>$2>>$3;$4
    """

  'in3':
    'prefix':'in3'
    'body':"""
    ${1:ll} $2,$3,$4;
    cin>>$2>>$3>>$4;$5
    """

  'in4':
    'prefix':'in4'
    'body':"""
    ${1:ll} $2,$3,$4,$5;
    cin>>$2>>$3>>$4>>$5;$6
    """

  'in5':
    'prefix':'in5'
    'body':"""
    ${1:ll} $2,$3,$4,$5,$6;
    cin>>$2>>$3>>$4>>$5>>$6;$7
    """

  'll1':
    'prefix':'ll1'
    'body':"""
    ll $1;
    cin>>$1;$2
    """

  'll2':
    'prefix':'ll2'
    'body':"""
    ll $1,$2;
    cin>>$1>>$2;$3
    """

  'll3':
    'prefix':'ll3'
    'body':"""
    ll $1,$2,$3;
    cin>>$1>>$2>>$3;$4
    """

  'll4':
    'prefix':'ll4'
    'body':"""
    ll $1,$2,$3,$4;
    cin>>$1>>$2>>$3>>$4;$5
    """

  'll5':
    'prefix':'ll5'
    'body':"""
    ll $1,$2,$3,$4,$5;
    cin>>$1>>$2>>$3>>$4>>$5;$6
    """

  'STR':
    'prefix':'STR'
    'body':'string ${1:s}; cin>>${1:s};$2'

  'ns':
    'prefix':'ns'
    'body':'ll n; string s; cin>>n>>s;'

  'vin':
    'prefix':'vin'
    'body':'for(auto &i:$1) {cin>>i;}$2'

  'vpin':
    'prefix':'vpin'
    'body':'for(auto &[x,y]:$1) {cin>>x>>y;}$2'

  'vvin':
    'prefix':'vvin'
    'body':'for(auto &i:$1){for(auto &j:i) {cin>>j;}}$2'

  'cout':
    'prefix':'c'
    'body':'cout<<${1:r}<<"\\\\n";$2'

  'cout_':
    'prefix':'cout'
    'body':'cout<<${1:r}<<"\\\\n";$2'

  'cout2':
    'prefix':'cout2'
    'body':'cout<<$1<<" "<<$2<<"\\\\n";$3'

  'cout3':
    'prefix':'cout3'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<"\\\\n";$4'

  'cout4':
    'prefix':'cout4'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<" "<<$4<<"\\\\n";$5'

  'cout5':
    'prefix':'cout5'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<" "<<$4<<" "<<$5<<"\\\\n";$6'

  'print':
    'prefix':'print'
    'body':'cout<<$1'

  'vout':
    'prefix':'vout'
    'body':'for(auto &${2:i}:$1) {cout<<${2:i}<<" ";}$3'

  'vpout':
    'prefix':'vpout'
    'body':'for(ll ${2:i}=0;${2:i}<${3:(ll)$1.size()};${2:i}++) {cout<<$1[${2:i}].first<<" "<<$1[${2:i}].second<<"${4:\\\\n}";}$5'

  'vvout':
    'prefix':'vvout'
    'body':'for(ll i=0;i<${2:(ll)$1.size()};i++){for(ll j=0;j<${3:(ll)$1[i].size()};j++) {cout<<$1[i][j]<<" ";}cout<<"\\\\n";}$4'

  'sout':
    'prefix':'sout'
    'body':'cout<<"$1\\\\n";$2'

  'iout':
    'prefix':'iout'
    'body':'cout<<($1==1e18?-1:$1)<<"\\\\n";$2'

  'debug':
    'prefix':'debug1'
    'body':'cerr<<"\\\\033[33m$1 : "<<$1<<"\\\\n\\\\033[m";$2'

  'debug2':
    'prefix':'debug2'
    'body':'cerr<<"\\\\033[33m($1, $2) : ("<<$1<<", "<<$2<<")\\\\n\\\\033[m";$3'

  'debug3':
    'prefix':'debug3'
    'body':'cerr<<"\\\\033[33m($1, $2, $3) : ("<<$1<<", "<<$2<<", "<<$3<<")\\\\n\\\\033[m";$4'

  'debug4':
    'prefix':'debug4'
    'body':'cerr<<"\\\\033[33m($1, $2, $3, $4) : ("<<$1<<", "<<$2<<", "<<$3<<", "<<$4<<")\\\\n\\\\033[m";$5'

  'debug5':
    'prefix':'debug5'
    'body':'cerr<<"\\\\033[33m($1, $2, $3, $4, $5) : ("<<$1<<", "<<$2<<", "<<$3<<", "<<$4<<", "<<$5<<")\\\\n\\\\033[m";$6'

  'debug_pair':
    'prefix':'debugp'
    'body':'cerr<<"\\\\033[33m$1 : ("<<$1.first<<", "<<$1.second<<")\\\\n\\\\033[m";$2'

  'debug_vector':
    'prefix':'debugv'
    'body':'for(ll I=0;I<ssize($1);I++) {cerr<<(I?"":"\\\\033[33m$1 : [")<<$1[I]<<(I==ssize($1)-1?"]\\\\n\\\\033[m":", ");}$2'

  'debug_vector_pair':
    'prefix':'debugvp'
    'body':'for(ll I=0;I<ssize($1);I++) {cerr<<(I?"(":"\\\\033[33m$1 : [(")<<$1[I].first<<", "<<$1[I].second<<(I==ssize($1)-1?")]\\\\n\\\\033[m":"), ");}$2'

  'debug_vector_2':
    'prefix':'debugvv'
    'body':"""
    for(ll I = 0; I < ssize($1); I++) {
      for(ll J = 0; J < ssize($1[I]); J++) {cerr << (J ? "" : "\\\\033[33m[") << $1[I][J] << (J == ssize($1[I]) - 1 ? "]\\\\n\\\\033[m" : ", ");}
    }$2
    """

  'debug_set':
    'prefix':'debugset'
    'body':'for(auto it = $1.begin(); it != $1.end(); it++) {cerr << (it == $1.begin() ? "\\\\033[33m$1 : {" : "") << *it << (it == prev($1.end()) ? "}\\\\n\\\\033[m" : ", ");}$2'

  'debug_map':
    'prefix':'debugmap'
    'body':'for(auto it = $1.begin(); it != $1.end(); it++) { cerr << (it == $1.begin() ? "\\\\033[33m$1 : [(" : "(") << it->first << ", " << it->second << (it == prev($1.end()) ? ")]\\\\n\\\\033[m" : "), "); }$2'

  'endl':
    'prefix':'en'
    'body':'cout<<"\\\\n";'

  'Yes':
    'prefix':'yes'
    'body':'cout<<"Yes\\\\n";'

  'No':
    'prefix':'no'
    'body':'cout<<"No\\\\n";'

  'yesno':
    'prefix':'yesno'
    'body':'cout<<(${1:flag}?"Yes\\\\n":"No\\\\n");$2'

  'first':
    'prefix':'fi'
    'body':'first'

  'second':
    'prefix':'sc'
    'body':'second'

  'make_pair':
    'prefix':'mp'
    'body':'make_pair($1)$2'

  'size':
    'prefix':'siz'
    'body':'size()'

  'ssize':
    'prefix':'ssiz'
    'body':'ssize($1)$2'

  'back':
    'prefix':'back'
    'body':'back()'

  'empty':
    'prefix':'empty'
    'body':'empty()'

  'while!empty':
    'prefix':'whileempty'
    'body':'while(!$1.empty()){$2}'

  'and':
    'prefix':'and'
    'body':'&&'

  'or':
    'prefix':'or'
    'body':'||'

  'not':
    'prefix':'not'
    'body':'!='

  'emplace_back':
    'prefix':'push_back'
    'body':'emplace_back($1);$2'

  'pop_back':
    'prefix':'pop_back'
    'body':'pop_back()'

  'emplace':
    'prefix':'emplace'
    'body':'emplace($1);$2'

  'insert':
    'prefix':'insert'
    'body':'insert($1);$2'

  'erase':
    'prefix':'erase'
    'body':'erase($1);$2'

  'break':
    'prefix':'bre'
    'body':'break;'

  'continue':
    'prefix':'continue'
    'body':'continue;'

  'exit':
    'prefix':'exit'
    'body':'return 0;'

  'return':
    'prefix':'return'
    'body':'return '

  'for':
    'prefix':'for'
    'body':'for(ll ${1:i}=0;${1:i}<${2:n};${1:i}++){$3}'

  'for_':
    'prefix':'for1'
    'body':'for(ll ${1:i}=1;${1:i}<=${2:n};${1:i}++){$3}'

  'lp':
    'prefix':'lp'
    'body':'for(ll ${1:i}=0;${1:i}<${2:n};${1:i}++){$3}'

  'lp_':
    'prefix':'lp_'
    'body':'for(ll ${1:i}=1;${1:i}<=${2:n};${1:i}++){$3}'

  'lpv':
    'prefix':'lpv'
    'body':'for(ll ${1:i}=0;${1:i}<ssize($2);${1:i}++){$3}'

  'lpa':
    'prefix':'lpa'
    'body':'for(auto &${1:i}:$2){$3}'

  'lpa2':
    'prefix':'lpa2'
    'body':'for(auto &[${1:x},${2:y}]:$3){$4}'

  'forauto':
    'prefix':'fora'
    'body':'for(auto &${1:i}:$2){$3}'

  'pl':
    'prefix':'pl'
    'body':'for(ll ${1:i}=$2;${1:i}>=0;${1:i}--){$3}'

  'mint_ini1000000007':
    'prefix':'mint0'
    'body':'using mint=modint1000000007;'

  'mint_ini998244353':
    'prefix':'mint9'
    'body':'using mint=modint998244353;'

  'mint_ini_arbitrary':
    'prefix':'minta'
    'body':'using mint=modint;'

  'mod_option':
    'prefix':'mod_option'
    'body':"""
    istream &operator>>(istream &is,mint &m) {ll n;is>>n;m=n;return is;}
    ostream &operator<<(ostream &os,const mint &m) {return os<<m.val();}
    mint operator^(const mint &x,const ll &n) {return x.pow(n);}
    mint operator^=(mint &x,const ll &n) {return x=x.pow(n);}
    """

  'setmod':
    'prefix':'setmod'
    'body':'modint::set_mod($1);$2'

  'pair':
    'prefix':'pair'
    'body':'pair<${1:ll},${2:ll}> $3'

  'pi':
    'prefix':'pi'
    'body':'pair<ll,ll> $1'

  'pd':
    'prefix':'pd'
    'body':'pair<long double,long double> $1'

  'pm':
    'prefix':'pm'
    'body':'pair<mint,mint> $1'

  'vector':
    'prefix':'vector'
    'body':'vector<'

  'v':
    'prefix':'v'
    'body':'vector<ll> ${1:v}'

  'vi':
    'prefix':'vi'
    'body':'vector<ll> ${1:v}'

  'vvi':
    'prefix':'vvi'
    'body':'vector<vector<ll>> ${1:v}(${2:h},vector<ll>(${3:w}))$4'

  'vd':
    'prefix':'vd'
    'body':'vector<long double> ${1:v}'

  'vvd':
    'prefix':'vvd'
    'body':'vector<vector<long double>> ${1:v}(${2:h},vector<long double>(${3:w}))$4'

  'vc':
    'prefix':'vc'
    'body':'vector<char> ${1:v}'

  'vvc':
    'prefix':'vvc'
    'body':'vector<vector<char>> ${1:v}(${2:h},vector<char>(${3:w}))$4'

  'vs':
    'prefix':'vs'
    'body':'vector<string> ${1:v}'

  'vvs':
    'prefix':'vvs'
    'body':'vector<vector<string>> ${1:v}($2,vector<string>($3))$4'

  'vm':
    'prefix':'vm'
    'body':'vector<mint> ${1:v}'

  'vvm':
    'prefix':'vvm'
    'body':'vector<vector<mint>> ${1:v}(${2:h},vector<mint>(${3:w}))$4'

  'vp':
    'prefix':'vp'
    'body':'vector<pair<${1:ll},${2:ll}>> ${3:v}'

  'vv':
    'prefix':'vv'
    'body':'vector<vector<${1:ll}>> $2'

  'vvv':
    'prefix':'vvv'
    'body':'vector<vector<vector<${1:ll}>>> $2'

  'vvv_':
    'prefix':'vvv_'
    'body':'vector<vector<vector<${1:ll}>>> ${2:v}($3,vector<vector<${1:ll}>>($4,vector<${1:ll}>($5)));$6'

  'vvvv':
    'prefix':'vvvv'
    'body':'vector<vector<vector<vector<${1:ll}>>>> $2'

  'vvvv_':
    'prefix':'vvvv_'
    'body':'vector<vector<vector<vector<${1:ll}>>>> ${2:v}($3,vector<vector<vector<${1:ll}>>>($4,vector<vector<${1:ll}>>($5,vector<${1:ll}>($6))));$7'

  'V':
    'prefix':'V'
    'body':"""
    vector<${1:ll}> ${2:v}(${3:n});
    for(auto &i:${2:v}) {cin>>i;}$4
    """

  'VI':
    'prefix':'VI'
    'body':"""
    vector<ll> ${1:v}(${2:n});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VD':
    'prefix':'VD'
    'body':"""
    vector<long double> ${1:v}(${2:n});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VC':
    'prefix':'VC'
    'body':"""
    vector<char> ${1:v}(${2:n});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VM':
    'prefix':'VM'
    'body':"""
    vector<mint> ${1:v}(${2:n});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VS':
    'prefix':'VS'
    'body':"""
    vector<string> ${1:v}(${2:n});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VP':
    'prefix':'VP'
    'body':"""
    vector<pair<ll,ll>> ${1:v}(${2:n});
    for(auto &[x,y]:${1:v}) {cin>>x>>y;}$3
    """

  'VV':
    'prefix':'VV'
    'body':"""
    vector<vector<${1:ll}>> ${2:v}(${3:h},vector<${1:ll}>(${4:w}));
    for(auto &i:${2:v}){for(auto &j:i){cin>>j;}}$5
    """

  'VVI':
    'prefix':'VVI'
    'body':"""
    vector<vector<ll>> ${1:v}(${2:h},vector<ll>(${3:w}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVD':
    'prefix':'VVD'
    'body':"""
    vector<vector<long double>> ${1:v}(${2:h},vector<long double>(${3:w}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVC':
    'prefix':'VVC'
    'body':"""
    vector<vector<char>> ${1:v}(${2:h},vector<char>(${3:w}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVS':
    'prefix':'VVS'
    'body':"""
    vector<vector<string>> ${1:v}(${2:h},vector<string>(${3:w}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVM':
    'prefix':'VVM'
    'body':"""
    vector<vector<mint>> ${1:v}(${2:h},vector<mint>(${3:w}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'lvi':
    'prefix':'lvi'
    'body':"""
    ll ${1:n}; cin>>${1:n};
    vector<ll> ${2:v}(${1:n});
    for(auto &i:${2:v}) {cin>>i;}
    $3
    """

  'lvp':
    'prefix':'lvp'
    'body':"""
    ll ${1:n}; cin>>${1:n};
    vector<pair<ll,ll>> ${2:v}(${1:n});
    for(auto &[x,y]:${2:v}) {cin>>x>>y;}
    $3
    """

  'set':
    'prefix':'set'
    'body':'set<${1:ll}> ${2:s};$3'

  'multiset':
    'prefix':'mset'
    'body':'multiset<${1:ll}> ${2:s};$3'

  'map':
    'prefix':'map'
    'body':'map<${1:ll},${2:ll}> ${3:m};$4'

  'unordered_map':
    'prefix':'umap'
    'body':'unordered_map<${1:ll},${2:ll}> ${3:m};$4'

  'queue':
    'prefix':'queue'
    'body':'queue<${1:ll}> ${2:q};$3'

  'priority_queue_greater':
    'prefix':'PQ'
    'body':'priority_queue<${1:ll},vector<${1:ll}>,greater<${1:ll}>> ${2:q};$3'

  'priority_queue':
    'prefix':'QP'
    'body':'priority_queue<${1:ll}> ${2:q};$3'

  'stack':
    'prefix':'stack'
    'body':'stack<${1:ll}> ${2:s};$3'

  'all':
    'prefix':'all'
    'body':'$1.begin(),$1.end()$2'

  'begin':
    'prefix':'begin'
    'body':'begin()'

  'end':
    'prefix':'end'
    'body':'end()'

  'sort':
    'prefix':'sort'
    'body':'ranges::sort($1);$2'

  'reverse':
    'prefix':'reverse'
    'body':'ranges::reverse($1);$2'

  'resort':
    'prefix':'resort'
    'body':'ranges::sort($1,ranges::greater());$2'

  'sum':
    'prefix':'sum'
    'body':'accumulate($1.begin(),$1.end(),${2:ll}(0))$3'

  'MAX':
    'prefix':'MAX'
    'body':'ranges::max($1)$2'

  'MIN':
    'prefix':'MIN'
    'body':'ranges::min($1)$2'

  'binary_search':
    'prefix':'BS'
    'body':'ranges::binary_search($1,$2)$3'

  'all_of':
    'prefix':'all_of'
    'body':'ranges::all_of($1,[](auto x){return $2;})$3'

  'any_of':
    'prefix':'any_of'
    'body':'ranges::any_of($1,[](auto x){return $2;})$3'

  'none_of':
    'prefix':'none_of'
    'body':'ranges::none_of($1,[](auto x){return $2;})$3'

  'AP':
    'prefix':'AP'
    'body':'for(ll ${3:i}=0;${3:i}<(ll)$1.size()) {$1[${3:i}]+=$2;}$4'

  'lower_bound':
    'prefix':'lb'
    'body':'ranges::lower_bound($1,$2)$3'

  'upper_bound':
    'prefix':'ub'
    'body':'ranges::upper_bound($1,$2)$3'

  'unique':
    'prefix':'unique'
    'body':'ranges::sort($1); $1.erase(unique($1.begin(),$1.end()),$1.end());$2'

  'Compress':
    'prefix':'Compress'
    'body':"""
    template<typename T> vector<T> Compress(vector<T> &v) {
      vector<T> r = v;
      ranges::sort(r);
      r.erase(unique(r.begin(), r.end()), r.end());
      for(auto &i : v) {i = ranges::lower_bound(r, i) - r.begin();}
      return r;
    }
    """

  'compress':
    'prefix':'compress'
    'body':'auto re=Compress($1);$2'

  'RLE_vec':
    'prefix':'RLE_vec'
    'body':"""
    template<typename T> vector<pair<T, ll>> RLE(const vector<T> &v) {
      ll p = -1, n = v.size();
      vector<pair<T, ll>> r;
      for(ll i = 0; i < n - 1; i++) {
        if(v[i] != v[i + 1]) {
          r.emplace_back(v[i], i - p);
          p = i;
        }
      }
      r.emplace_back(v.back(), n - 1 - p);
      return r;
    }
    """

  'RLE_str':
    'prefix':'RLE_str'
    'body':"""
    vector<pair<char, ll>> RLE(const string &s) {
      ll p = -1, n = s.size();
      vector<pair<char, ll>> r;
      for(ll i = 0; i < n - 1; i++) {
        if(s[i] != s[i + 1]) {
          r.emplace_back(s[i], i - p);
          p = i;
        }
      }
      r.emplace_back(s.back(), n - 1 - p);
      return r;
    }
    """

  'ACSUM':
    'prefix':'ACSUM'
    'body':"""
    vector<ll> s${1:v}(${2:${1:v}.size()}+1,0);
    for(ll i=0;i<${2:${1:v}.size()};i++) {s${1:v}[i+1]=s${1:v}[i]+${1:v}[i];}$3
    """

  'next_permutation':
    'prefix':'next_permutation'
    'body':"""
    do{
      $2
    }while(next_permutation($1.begin(),$1.end()));
    """

  'next_combination':
    'prefix':'next_combination'
    'body':"""
    vector<bool> o(n, false);
    fill(o.end() - n + k, o.end(), true);
    do {
      vector<ll> r;
      for(int i = 0; i < n; i++) {
        if(!o[i]) { r.push_back(i); }
      }
    } while(next_permutation(o.begin(), o.end()));
    """

  'ExtGCD':
    'prefix':'ExtGCD'
    'body':"""
    // return : gcd(a,b), {x,y} -> soltion of ax + by = gcd(a,b)
    template<typename T> T extGCD(T a, T b, T &x, T &y) {
      T g = a;
      if(b != 0) {
        g = extGCD(b, a % b, y, x);
        y -= (a / b) * x;
      }
      else {x = 1, y = 0;}
      return g;
    }
    """

  'extGCD':
    'prefix':'extGCD'
    'body':'extGCD($1,$2,$3,$4);$5'

  'Combinatorics':
    'prefix':'Combinatorics'
    'body':"""
    struct Combinatorics {
     private:
      void extend(int m) {
        int n = fac.size();
        m = min(m, mint::mod() - 1);
        if(n > m) { return; }
        fac.resize(m + 1);
        finv.resize(m + 1);
        inv.resize(m + 1);
        for(int i = n; i <= m; i++) { fac[i] = fac[i - 1] * i; }
        finv[m] = fac[m].inv();
        for(int i = m - 1; i >= n; i--) { finv[i] = finv[i + 1] * (i + 1); }
        for(int i = n; i <= m; i++) { inv[i] = finv[i] * fac[i - 1]; }
      }

     public:
      vector<mint> fac, finv, inv;
      Combinatorics(int n = 0): fac(1, 1), finv(1, 1), inv(1, 1) { extend(n); }
      mint operator()(int n) {
        extend(abs(n));
        return n >= 0 ? fac[n] : finv[-n];
      }
      mint operator[](int n) {
        extend(abs(n));
        return n >= 0 ? inv[n] : -inv[-n];
      }
      mint C(int n, int k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        extend(n);
        return fac[n] * finv[n - k] * finv[k];
      }
      inline mint operator()(int n, int k) { return C(n, k); }
      mint C_(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        k = min(k, n - k);
        extend(k);
        mint r = 1;
        for(ll i = 0; i < k; i++) { r *= n - i; }
        return r * finv[k];
      }
      mint P(int n, int k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        extend(n);
        return fac[n] * finv[n - k];
      }
      mint P_(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        k = min(k, n - k);
        mint r = 1;
        for(ll i = 0; i < k; i++) { r *= n - i; }
        return r;
      }
      mint H(int n, int k) {
        if(n < 0 || k < 0) { return 0; }
        if(n == 0 && k == 0) { return 1; }
        return C(n + k - 1, k);
      }
      mint multi(const vector<ll> &v) {
        int n = 0;
        for(auto &i : v) {
          if(i < 0) { return 0; }
          n += i;
        }
        extend(n);
        mint r = fac[n];
        for(auto &i : v) { r *= finv[i]; }
        return r;
      }
      mint operator()(const vector<ll> &v) { return multi(v); }
      mint Catalan(int n) {
        if(n < 0) { return 0; }
        extend(n * 2);
        return fac[n * 2] * finv[n] * finv[n + 1];
      }
      mint Bell(int n, int k) {
        if(n < 0 || k < 0) { return 0; }
        if(n == 0) { return 1; }
        k = min(n, k);
        extend(k);
        mint r = 0;
        vector<mint> v(k + 1);
        v[0] = 1;
        for(ll i = 1; i <= k; i++) { v[i] = v[i - 1] + (i & 1 ? -finv[i] : finv[i]); }
        for(ll i = 1; i <= k; i++) { r += (mint(i).pow(n)) * finv[i] * v[k - i]; }
        return r;
      }
      mint Stirling(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        mint r = 0;
        for(ll i = 0; i <= k; i++) {
          mint t = C(k, i) * (mint(i).pow(n));
          r += (k - i) & 1 ? -t : t;
        }
        return r * finv[k];
      }
    } C;  ${1:// 任意modの場合，main関数内に書くこと}
    """

  'combinatrics':
    'prefix':'combinatrics'
    'body':'Combinatorics C($1);'

  'COMTable':
    'prefix':'COMTable'
    'body':"""
    vector<vector<mint>> COMTable(ll n) {  // If n is small
      vector<vector<mint>> r(n + 1, vector<mint>(n + 1, 0));
      for(ll i = 0; i <= n; i++) {
        for(ll j = 0; j <= i; j++) {
          if(j == 0 || j == i) {r[i][j] = 1;}
          else {r[i][j] = r[i - 1][j - 1] + r[i - 1][j];}
        }
      }
      return r;
    }
    """

  'comtable':
    'prefix':'comtable'
    'body':'auto C=COMTable($1);$2'

  'Stirling_number_2_Table':
    'prefix':'Stirling_number_2_Table'
    'body':"""
    vector<vector<mint>> StirlingTable(ll n) {
      vector<vector<mint>> r(n + 1, vector<mint>(n + 1, 0));
      r[0][0] = 1;
      for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= i; j++) {
          r[i][j] = r[i - 1][j - 1] + r[i - 1][j] * j;
        }
      }
      return r;
    }
    """

  'Partition_number':
    'prefix':'Partition_number'
    'body':"""
    vector<vector<mint>> Partition(ll n) {
      vector<vector<mint>> r(n + 1, vector<mint>(n + 1, 0));
      for(ll i = 0; i <= n; i++) {r[0][i] = 1;}
      for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= n; j++) {
          r[i][j] = r[i][j - 1] + (i - j >= 0 ? r[i - j][j] : 0);
        }
      }
      return r;
    }
    """

  'Base':
    'prefix':'Base'
    'body':"""
    vector<ll> Base(ll x, ll n, bool re = false) {
      vector<ll> r;
      while(x != 0) {
        r.emplace_back(x % n);
        (x -= (x % n)) /= n;
      }
      if(re) {ranges::reverse(r);}
      return r;
    }
    """

  'base':
    'prefix':'base'
    'body':'=Base($1,$2)'

  'Prime':
    'prefix':'Prime'
    'body':"""
    vector<pair<ll, ll>> Prime(ll n) {
      vector<pair<ll, ll>> r;
      for(ll i = 2; i*i <= n; i++) {
        if(n % i != 0) {continue;}
        ll e = 0;
        while(n % i == 0) {e++, n /= i;}
        r.emplace_back(i, e);
      }
      if(n != 1) {r.emplace_back(n, 1);}
      return r;
    }
    """

  'prime':
    'prefix':'prime'
    'body':'Prime($1)'

  'PriMap':
    'prefix':'PriMap'
    'body':"""
    map<ll, ll> PriMap(ll n) {
      map<ll, ll> r;
      for(ll i = 2; i*i <= n; i++) {
        while(n % i == 0) {r[i]++, n /= i;}
      }
      if(n != 1){r[n] = 1;}
      return r;
    }
    """

  'primap':
    'prefix':'primap'
    'body':'PriMap($1)'

  'Divisor':
    'prefix':'Div'
    'body':"""
    vector<ll> Div(ll n) {
      vector<ll> r;
      for(ll i = 1; i *i<= n; i++) {
        if(n % i == 0) {
          r.emplace_back(i);
          if(i * i != n) {r.emplace_back(n / i);}
        }
      }
      ranges::sort(r);
      return r;
    }
    """

  'divisor':
    'prefix':'div'
    'body':'Div($1);'

  'Divcnt':
    'prefix':'Divcnt'
    'body':"""
    ll Divcnt(ll n, ll d) {
      ll r = 0;
      while(n % d == 0) {n /= d, r++;}
      return r;
    }
    """

  'divcnt':
    'prefix':'divcnt'
    'body':'Divcnt($1,$2)'

  'DigSum':
    'prefix':'DigSum'
    'body':"""
    ll DigSum(ll n){
      ll r=0;
      while(n){
        r+=n%10;
        n/=10;
      }
      return r;
    }
    """

  'digsum':
    'prefix':'digsum'
    'body':'Digsum($1)'

  'Enum_Q':
    'prefix':'Enum_Q'
    'body':"""
    vector<pair<pair<ll, ll>, ll>> Enum_Q(ll n) {
      vector<pair<pair<ll, ll>, ll>> ret;
      ll l = 1;
      while(l <= n) {
        ll q = n / l, r = n / q + 1;
        ret.push_back({{l, r}, q});
        l = r;
      }
      return ret;
    }
    """

  'enum_Q':
    'prefix':'enum_Q'
    'body':'Enum_Q($1)'

  'PSUM':
    'prefix':'_PSUM'
    'body':"""
    mint PSUM(const vector<ll> &v, ll s) {
      ll n = v.size();
      vector<vector<mint>> dp(n + 3, vector<mint>(s + 3, 0));
      dp[0][0] = 1;
      for(ll i = 0; i < n; i++) {
        for(ll j = 1; j <= s; j++) {
          dp[i + 1][j] += dp[i][j];
          if(j >= v[i]) dp[i + 1][j] += dp[i][j - v[i]];
        }
      }
      return dp[n][s];
    }
    """

  'INF':
    'prefix':'inf'
    'body':'1e18'

  'FNI':
    'prefix':'fni'
    'body':'-1e18'

  'LIS':
    'prefix':'LIS'
    'body':"""
    template<typename T> vector<T> LIS(const vector<T> &v, bool strict = 1) {
      vector<T> lis;
      for(auto &i : v) {
        auto it = (strict ? ranges::lower_bound(lis, i) : ranges::upper_bound(lis, i));
        it == lis.end() ? lis.emplace_back(i) : *it = i;
      }
      return lis;
    }
    """

  'DXDY':
    'prefix':'DXDY'
    'body':'constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};'

  'chmin_func':
    'prefix':'chmin_func'
    'body':'auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };'

  'chmax_func':
    'prefix':'chmax_func'
    'body':'auto chmax = [&](auto &a, const auto &b) { return a < b ? (a = b, true) : false; };'

  'YN':
    'prefix':'YN'
    'body':'cout << (${1:f} ? "Yes" : "No") << "\\\\n";$2'

  'bitset':
    'prefix':'bit'
    'body':'bitset<70> $1($2);$3'

  'floor_sum':
    'prefix':'floor_sum'
    'body':'floor_sum(,,,); // (n,m,a,b) -> Σ i=0~n-1 floor((a*i+b)/m)'

  'lambda':
    'prefix':'lambda'
    'body':"""
    auto ${1:f}=[&]($2){
      $3
    };
    """

  'lambda_':
    'prefix':'Lambda'
    'body':"""
    auto ${1:f}=[&](auto &&${1:f},$2)->$3{
      $4
    };
    """

  'binmax':
    'prefix':'binmax'
    'body':"""
    for(ll L = , R = ;;) {
      if(R - L <= 1) {
        cout << L << "\\\\n";
        break;
      }
      ll M = (L + R) / 2;
      bool flag=0;
      $1
      flag ? L = M : R = M;
    }
    """

  'binmax_func':
    'prefix':'binmax_func'
    'body':"""
    function<void(ll, ll)> f = [&](ll L, ll R) {
      if(R - L <= 1) cout << L << "\\\\n";
      else {
        ll M = (L + R) / 2;
        bool flag = 0;
        $1
        flag ? f(M, R) : f(L, M);
      }
    };
    """

  'binmin':
    'prefix':'binmin'
    'body':"""
    for(ll L = , R = ;;) {
      if(R - L <= 1) {
        cout << R << "\\\\n";
        break;
      }
      ll M = (L + R) / 2;
      bool flag=0;
      $1
      flag ? R = M : L = M;
    }
    """

  'binmin_func':
    'prefix':'binmin_func'
    'body':"""
    function<void(ll, ll)> f = [&](ll L, ll R) {
      if(R - L <= 1) cout << R << "\\\\n";
      else {
        ll M = (L + R) / 2;
        bool flag = 0;
        $1
        flag ? f(L, M) : f(M, R);
      }
    };
    """

  'graph':
    'prefix':'graph'
    'body':"""
    vector<vector<ll>> g(${1:n});
    for(ll i=0,u,v;i<${2:m};i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$3
    """

  'lgraph':
    'prefix':'lgraph'
    'body':"""
    ll ${1:n},${2:m};
    cin>>${1:n}>>${2:m};
    vector<vector<ll>> g(${1:n});
    for(ll i=0,u,v;i<${2:m};i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$3
    """

  'tree':
    'prefix':'tree'
    'body':"""
    vector<vector<ll>> g(${1:n});
    for(ll i=0,u,v;i<${1:n}-1;i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$2
    """

  'ltree':
    'prefix':'ltree'
    'body':"""
    ll ${1:n};
    cin>>${1:n};
    vector<vector<ll>> g(${1:n});
    for(ll i=0,u,v;i<${1:n}-1;i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$2
    """

  'wgraph':
    'prefix':'wgraph'
    'body':"""
    vector<vector<pair<ll,ll>>> g(${1:n});
    for(ll i=0,u,v,w;i<${2:m};i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$3
    """

  'lwgraph':
    'prefix':'lwgraph'
    'body':"""
    ll ${1:n},${2:m};
    cin>>${1:n}>>${2:m};
    vector<vector<pair<ll,ll>>> g(${1:n});
    for(ll i=0,u,v,w;i<${2:m};i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$3
    """

  'wtree':
    'prefix':'wtree'
    'body':"""
    vector<vector<pair<ll,ll>>> g(${1:n});
    for(ll i=0,u,v,w;i<${1:n}-1;i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$2
    """

  'lwtree':
    'prefix':'lwtree'
    'body':"""
    ll ${1:n};
    cin>>${1:n};
    vector<vector<pair<ll,ll>>> g(${1:n});
    for(ll i=0,u,v,w;i<${1:n}-1;i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$2
    """

  'DFS':
    'prefix':'DFS'
    'body':"""
    auto DFS = [&](auto &&DFS, ll v, ll p) -> void {
      for(auto &nv : g[v]) {
        if(nv != p) {DFS(DFS, nv, v);}
      }
    };
    """

  'DFS_tree':
    'prefix':'DFS_tree'
    'body':"""
    vector<ll> depth(n, -1);
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      depth[v] = d;
      for(auto &nv : g[v]) {
        if(nv == p) {continue;}
        DFS(DFS, nv, v, d + 1);
      }
    };
    """

  'DFS_tree_size':
    'prefix':'DFS_tree_size'
    'body':"""
    vector<ll> depth(n,-1),par(n,-1), order, tsiz(n);
    function<void(ll, ll, ll)> DFS = [&](ll v, ll p, ll d) {
      depth[v] = d;
      par[v]=p;
      order.emplace_back(v);
      for(auto &nv : g[v]) {
        if(nv != p) {DFS(nv, v, d + 1);}
      }
      tsiz[v] = 1;
      for(auto &nv : g[v]) {
        if(nv != p) {tsiz[v] += tsiz[nv];}
      }
    };
    """

  'BFS_func':
    'prefix':'BFS_func'
    'body':"""
    auto BFS = [&](ll s) {
      vector<ll> d(n, -1);
      d[s] = 0;
      queue<ll> q;
      q.emplace(s);
      while(!q.empty()) {
        ll v = q.front();
        q.pop();
        for(auto &nv : g[v]) {
          if(d[nv] == -1) {
            d[nv] = d[v] + 1;
            q.emplace(nv);
          }
        }
      }
      return d;
    };
    """

  'BFS':
    'prefix':'BFS'
    'body':"""
    vector<ll> d(n, -1);
    d[0] = 0;
    queue<ll> q;
    q.emplace(0);
    while(!q.empty()) {
      ll v = q.front();
      q.pop();
      for(auto &nv : g[v]) {
        if(d[nv] == -1) {
          d[nv] = d[v] + 1;
          q.emplace(nv);
        }
      }
    }
    """

  'BFS_re_func':
    'prefix':'BFS_re_func'
    'body':"""
    auto BFS = [&](ll s, ll t) -> pair<vector<ll>, vector<ll>> {
      vector<ll> d(n, -1), pre(n), path;
      d[s] = 0;
      queue<ll> q;
      q.emplace(s);
      while(!q.empty()) {
        ll v = q.front();
        q.pop();
        for(auto &nv : g[v]) {
          if(d[nv] == -1) {
            d[nv] = d[v] + 1;
            q.emplace(nv);
            pre[nv] = v;
          }
        }
      }
      if(d[t] != -1) {
        for(ll p = t; p != s; p = pre[p]) { path.emplace_back(p); }
        path.emplace_back(s);
        ranges::reverse(path);
      }
      return {d, path};
    };
    """

  'BFS_re':
    'prefix':'BFS_re'
    'body':"""
    vector<ll> d(n, -1), pre(n), path;
    d[s] = 0;
    queue<ll> q;
    q.emplace(s);
    while(!q.empty()) {
      ll v = q.front();
      q.pop();
      for(auto &nv : g[v]) {
        if(d[nv] == -1) {
          d[nv] = d[v] + 1;
          q.emplace(nv);
          pre[nv] = v;
        }
      }
    }
    if(d[t] != -1) {
      for(ll p = t; p != s; p = pre[p]) {path.emplace_back(p);}
      path.emplace_back(s);
      ranges::reverse(path);
    }
    """

  'BFS_grid':
    'prefix':'BFS_grid'
    'body':"""
    constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};

    template<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {
      ll limx = g.size(), limy = g[0].size();
      if(ini) d.assign(limx, vector<ll>(limy, 1e18));
      d[s.first][s.second] = 0;
      queue<pair<ll, ll>> q;
      q.push(s);
      while(!q.empty()) {
        auto [x,y]=q.front();
        q.pop();
        for(ll i = 0; i < 4; i++) {
          ll nx = x + DX[i], ny = y + DY[i];
          if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}
          if(g[nx][ny] == w) {continue;}
          if(chmin(d[nx][ny], d[x][y] + 1)) {q.push({nx, ny});}
        }
      }
    }
    """

  '01BFS_grid':
    'prefix':'01BFS_grid'
    'body':"""
    constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};

    template<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {
      ll limx = g.size(), limy = g[0].size();
      if(ini) {d.assign(limx, vector<ll>(limy, 1e18));}
      d[s.first][s.second] = 0;
      deque<pair<ll, ll>> q;
      q.push_back(s);
      while(!q.empty()) {
        auto [x,y]=q.front();
        q.pop_front();
        for(ll i = 0; i < 4; i++) {
          ll nx = x + DX[i], ny = y + DY[i];
          if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}
          if(g[nx][ny] == w) {
            if(chmin(d[nx][ny], d[x][y] + 1)) {q.push_back({nx, ny});}
          }
          else if(chmin(d[nx][ny], d[x][y])) {q.push_front({nx, ny});}
        }
      }
    }
    """

  'Dijkstra':
    'prefix':'Dijkstra'
    'body':"""
    vector<ll> d(n, 1e18);
    d[0] = 0;
    auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };
    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;
    q.emplace(0, 0);
    while(!q.empty()) {
      auto [tmp, v] = q.top();
      q.pop();
      if(tmp > d[v]) {continue;}
      for(auto &[nv, c] : g[v]) {
        if(chmin(d[nv], d[v] + c)) {q.emplace(d[nv], nv);}
      }
    }
    """

  'Dijkstra_func':
    'prefix':'Dijkstra_func'
    'body':"""
    auto Dijkstra = [&](ll s) {
      auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };
      vector<ll> d(n, 1e18);
      d[s] = 0;
      priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;
      q.emplace(0, s);
      while(!q.empty()) {
        auto [tmp, v] = q.top();
        q.pop();
        if(tmp > d[v]) { continue; }
        for(auto &[nv, c] : g[v]) {
          if(chmin(d[nv], d[v] + c)) { q.emplace(d[nv], nv); }
        }
      }
      return d;
    };
    """

  'Dijkstra_re':
    'prefix':'Dijkstra_re'
    'body':"""
    template<typename T> vector<ll> Dijkstra_re(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s, ll t, bool ini = 1) {  // O(E log V)
      vector<ll> pre(g.size()), re;
      if(ini) {d.assign(g.size(), 1e18);}
      d[s] = 0;
      priority_queue<pair<T, ll>, vector<pair<T, ll>>, greater<pair<T, ll>>> q;
      q.push({T(0), s});
      while(!q.empty()) {
        pair<T, ll> p = q.top();
        q.pop();
        ll v = p.second;
        if(p.first > d[v]) {continue;}
        for(auto &[nv,c] : g[v]) {
          if(chmin(d[nv], d[v] + c)) {
            q.push({d[nv], nv});
            pre[nv] = v;
          }
        }
      }
      if(d[t] != 1e18) {
        for(ll p = t; p != s; p = pre[p]) {re.emplace_back(p);}
        re.emplace_back(s);
        ramge::reverse(re);
      }
      return re;
    }
    """

  'BellmanFord':
    'prefix':'BellmanFord'
    'body':"""
    template<typename T> bool BellmanFord(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s = 0, bool ini = 1) {  // O(VE)
      bool nega_cycle = false;
      ll n = g.size();
      if(ini) {d.assign(n, 1e18);}
      d[s] = 0;
      for(ll i = 0; i < n; i++) {
        bool update = 0;
        for(ll v = 0; v < n; v++) {
          if(d[v] == 1e18) {continue;}
          for(auto &[nv,c] : g[v]) {
            if(chmin(d[nv], d[v] + c)) {update = 1;}
          }
        }
        if(!update) {break;}
        if(i == n - 1) {nega_cycle = true;}
      }
      return nega_cycle;
    }
    """

  'bellmanford':
    'prefix':'bellmanford'
    'body':'BellmanFord(g,d);'

  'WarshallFroyd':
    'prefix':'WarshallFroyd'
    'body':"""
    template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g) {  // O(V^3)
      ll n = g.size();
      vector<vector<T>> w(n, vector<T>(n, 1e18));
      for(ll i = 0; i < n; i++) {w[i][i] = 0;}
      for(ll i = 0; i < n; i++) {
        for(auto &[j,c] : g[i]) {w[i][j] = c;}
      }
      for(ll via = 0; via < n; via++) {
        for(ll i = 0; i < n; i++) {
          for(ll j = 0; j < n; j++) {w[i][j]=min(w[i][j], w[i][via] + w[via][j]);}
        }
      }
      return w;
    }
    """

  'warshallfroyd':
    'prefix':'warshallfroyd'
    'body':'WarshallFroyd(g)'

  'WarshallFroyd_re':
    'prefix':'WarshallFroyd_re'
    'body':"""
    template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g, vector<vector<ll>> &pre) {
      ll n = g.size();
      vector<vector<T>> w(n, vector<T>(n, 1e18));
      for(ll i = 0; i < n; i++) {
        vector<ll> p(n, i);
        pre.emplace_back(p);
      }
      for(ll i = 0; i < n; i++) {w[i][i] = 0;}
      for(ll i = 0; i < n; i++) {
        for(auto &[j,c] : g[i]) {w[i][j] = c;}
      }
      for(ll via = 0; via < n; via++) {
        for(ll i = 0; i < n; i++) {
          for(ll j = 0; j < n; j++) {
            if(chmin(w[i][j], w[i][via] + w[via][j])) {pre[i][j] = pre[via][j];}
          }
        }
      }
      return w;
    }
    vector<ll> WarshallFroyd_re(vector<vector<ll>> &pre, ll s, ll t) {
      vector<ll> r;
      for(ll p = t; p != s; p = pre[s][p]) {r.emplace_back(p);}
      r.emplace_back(s);
      ranges::reverse(r);
      return r;
    }
    """

  'warshallfroyd_re':
    'prefix':'warshallfroyd_re'
    'body':'WarshallFroyd_re(pre,$1,$2)'

  'Topological_sort':
    'prefix':'Topological_sort'
    'body':"""
    vector<ll> sort(vector<vector<ll>> &g) {
      ll n = g.size();
      vector<ll> r, e(n);
      priority_queue<ll, vector<ll>, greater<ll>> q;
      for(ll i = 0; i < n; i++) {
        for(auto &v : g[i]) {e[v]++;}
      }
      for(ll i = 0; i < n; i++) {
        if(e[i] == 0) {q.emplace(i);}
      }
      while(!q.empty()) {
        ll v = q.top();
        q.pop();
        r.emplace_back(v);
        for(auto &nv : g[v]) {
          e[nv]--;
          if(e[nv] == 0) {q.emplace(nv);}
        }
      }
      return r;
    }
    """

  'Topological_sort_w':
    'prefix':'Topological_sort_w'
    'body':"""
    template<typename T> vector<ll> sort(vector<vector<pair<ll,T>>> &g) {
      ll n = g.size();
      vector<ll> r, e(n);
      priority_queue<ll, vector<ll>, greater<ll>> q;
      for(ll i = 0; i < n; i++) {
        for(auto &v : g[i]) {e[v.second]++;}
      }
      for(ll i = 0; i < n; i++) {
        if(e[i] == 0) {q.emplace(i);}
      }
      while(!q.empty()) {
        ll v = q.top();
        q.pop();
        r.emplace_back(v);
        for(auto &[nv,c] : g[v]) {
          e[nv]--;
          if(e[nv] == 0) {q.emplace(nv);}
        }
      }
      return r;
    }
    """

  'TreeDiameter':
    'prefix':'_TreeDiameter'
    'body':"""
    ll TreeDiameter(vector<vector<ll>> &g) {
      vector<ll> D(g.size(), -1);
      function<void(ll, ll)> DFS = [&](ll v, ll d) {
        D[v] = d;
        for(auto &nv : g[v]) {
          if(D[nv] < 0) {DFS(nv, d + 1);}
        }
      };
      DFS(0, 0);
      ll v = ranges::max_element(D) - D.begin();
      D.assign(g.size(), -1);
      DFS(v, 0);
      return ranges::max(D);
    }
    """

  'TreeDiameter_w':
    'prefix':'_TreeDiameter_w'
    'body':"""
    pair<pair<ll, ll>, ll> TreeDiameter(vector<vector<pair<ll, ll>>> &g) {
      vector<ll> D(g.size(), -1);
      function<void(ll, ll)> DFS = [&](ll v, ll d) {
        D[v] = d;
        for(auto &[nv, c] : g[v]) {
          if(D[nv] < 0) {DFS(nv, d + c);}
        }
      };
      DFS(0, 0);
      ll v = ranges::max_element(D) - D.begin();
      D.assign(g.size(), -1);
      DFS(v, 0);
      ll u = ranges::max_element(D) - D.begin();
      ll w = ranges::max(D);
      return {{u, v}, w};
    }
    """

  'Bipartite':
    'prefix':'Bipartite'
    'body':"""
    vector<ll> Bipartite(vector<vector<ll>>& g) {
      ll n = g.size();
      vector<ll> color(n, -1);
      function<bool(ll, ll)> DFS = [&](ll v, ll c) {
        color[v] = c;
        for(auto &nv : g[v]) {
          if(color[nv] != -1) {
            if(color[nv] == c) {return false;}
            continue;
          }
          if(!DFS(nv, 1 - c)) {return false;}
        }
        return true;
      };
      for(ll i = 0; i < n; i++) {
        if(color[i] == -1) {
          if(!DFS(i, 0)) {return {};}
        }
      }
      return color;
    }
    """

  'bipartite':
    'prefix':'bipartite'
    'body':'Bipartite(g);'

  'LagrangePolynomial':
    'prefix':'Lagrange'
    'body':"""
    mint LagrangePolynomial(vector<ll> &v, ll x) {
      ll N = v.size() - 1;
      mint r = 0;
      if(x <= N) { return v[x]; }
      vector<mint> dp(N + 1, 1), pd(N + 1, 1);
      for(ll i = 0; i < N; i++) { dp[i + 1] = dp[i] * (x - i); }
      for(ll i = N; i >= 1; i--) { pd[i - 1] = pd[i] * (x - i); }
      for(ll i = 0; i <= N; i++) {
        mint t = dp[i] * pd[i] * C(-i) * C(i - N) * v[i];
        r += (N - i) & 1 ? -t : t;
      }
      return r;
    }
    // depends on : Combinatorics
    """

  'lagrangepolynomial':
    'prefix':'lagrange'
    'body':'LagrangePolynomial($1,$2)'

  'Fibo':
    'prefix':'Fibo'
    'body':"""
    template<typename T = mint> T Fibo(ll n) {
      vector<vector<T>> v = {{1, 1}, {1, 0}};
      Matrix<T> M(v);
      M ^= (n - 1);
      return M[0][0];
    }
    // depends on : Matrix
    """

  'fibo':
    'prefix':'fibo'
    'body':'Fibo($1);'

  'mypq':
    'prefix':'mypq'
    'body':"""
    auto compare=[]($1 x,$1 y){return $2;}; // condition to put y near top
    priority_queue<$1,vector<$1>,decltype(compare)> q(compare);
    """

  'RNG':
    'prefix':'RNG'
    'body':"""
    struct RNG{
      mt19937 mt;
      RNG():mt(chrono::steady_clock::now().time_since_epoch().count()){}
      int operator()(int a,int b){uniform_int_distribution<int>dist(a,b);return dist(mt);}
      int operator()(int b){return(*this)(0,b);}
    }rng;
    """

  'Inversion':
    'prefix':'Inversion'
    'body':"""
    ll Inversion(vector<ll> &v) {
      ll r = 0, n = v.size();
      // Compress(v);
      fenwick_tree<ll> b(n + 1);
      for(ll i = 0; i < n; i++) {
        r += b.sum(v[i]+1, n + 1);
        b.add(v[i], 1);
      }
      return r;
    }
    """

  'inversion':
    'prefix':'inversion'
    'body':'Inversion($1);'

  'Unionfind':
    'prefix':'Unionfind'
    'body':"""
    struct Unionfind {
      vector<ll> par;
      ll e = 0, v;
      Unionfind(ll n): par(n, -1), v(n) {}
      Unionfind(vector<vector<ll>> g): par(g.size(), -1), v(g.size()) {
        for(ll i = 0; i < v; i++) {
          for(auto &j : g[i]) {
            if(i < j) {unite(i, j);}
          }
        }
      }
      ll root(ll x) {
        if(par[x] < 0) {return x;}
        return par[x] = root(par[x]);
      }
      void unite(ll x, ll y) {
        x = root(x), y = root(y);
        if(x == y) {return;}
        if(par[x] > par[y]) {swap(x, y);}
        par[x] += par[y];
        par[y] = x;
        e++;
      }
      void unite(pair<ll, ll> x) { unite(x.first, x.second); }
      bool same(ll x, ll y) { return root(x) == root(y); }
      bool same(pair<ll, ll> x) { return same(x.first, x.second); }
      ll size(ll x) { return -par[root(x)]; }
      vector<vector<ll>> group() {
        vector<vector<ll>> r(v);
        for(ll i = 0; i < v; i++) {r[root(i)].emplace_back(i);}
        r.erase(remove_if(begin(r), end(r), [&](vector<ll> &r_) { return r_.empty(); }));
        return r;
      }
      ll operator[](ll i) { return root(i); }
      void operator()(ll x, ll y) { unite(x, y); }
      void operator()(pair<ll, ll> x) { unite(x); }
      ll operator()() { return v - e; }
    };
    """

  'unionfind':
    'prefix':'unionfind'
    'body':'Unionfind u(n);'

  'CycleCheck':
    'prefix':'cycle'
    'body':"""
    bool CycleCheck(graph &g) {
      Unionfind u(g.size());
      for(ll i = 0; i < g.size(); i++) {
        for(auto &j : g[i]) {
          if(i < j && u.same(i, j)) {return true;}
          u(i, j);
        }
      }
      return false;
    }
    // depends on : graph , Unionfind
    """

  'Rollback_Unionfind':
    'prefix':'Rollback_Unionfind'
    'body':"""
    struct Rollback_Unionfind {
      vector<ll> par;
      stack<pair<ll, ll>> history;
      Rollback_Unionfind(ll n): par(n, -1) {}
      ll root(ll x) {
        if(par[x] < 0) {return x;}
        else {return root(par[x]);}
      }
      void unite(ll x, ll y) {
        x = root(x), y = root(y);
        history.emplace(x, par[x]);
        history.emplace(y, par[y]);
        if(x == y) {return;}
        if(par[x] > par[y]) {swap(x, y);}
        par[x] += par[y];
        par[y] = x;
      }
      void unite(pair<ll, ll> x) { unite(x.first, x.second); }
      bool same(ll x, ll y) { return root(x) == root(y); }
      bool same(pair<ll, ll> x) { return same(x.first, x.second); }
      ll size(ll x) { return -par[root(x)]; }
      void undo() {
        for(ll i = 0; i < 2; i++) {
          par[history.top().first] = history.top().second;
          history.pop();
        }
      }
      void snapshot() {
        while(!history.empty()) {history.pop();}
      }
      void rollback() {
        while(!history.empty()) {undo();}
      }
      ll operator[](ll i) { return root(i); }
      void operator()(ll x, ll y) { unite(x, y); }
      void operator()(pair<ll, ll> x) { unite(x); }
    };
    """

  'rollback_unionfind':
    'prefix':'rollback_unionfind'
    'body':'Rollback_Unionfind u(n);'

  'WeightedUnionfind':
    'prefix':'WeightedUnionfind'
    'body':"""
    template<typename T> struct WeightedUnionfind {
      vector<ll> par, rank;
      vector<T> diff_;
      WeightedUnionfind(ll n): par(n), rank(n), diff_(n) {
        for(ll i = 0; i < n; i++) {par[i] = i, rank[i] = diff_[i] = 0;}
      }
      ll root(ll x) {
        if(par[x] == x) {return x;}
        else {
          ll r = root(par[x]);
          diff_[x] += diff_[par[x]];
          return par[x] = r;
        }
      }
      T weight(ll x) {
        root(x);
        return diff_[x];
      }
      void unite(ll x, ll y, T w) {
        w += weight(x) - weight(y);
        x = root(x), y = root(y);
        if(x == y) {return;}
        if(rank[x] < rank[y]) {swap(x, y), w = -w;}
        if(rank[x] == rank[y]) {rank[x]++;}
        par[y] = x;
        diff_[y] = w;
      }
      void unite(pair<ll, ll> x, T w) { unite(x.first, x.second, w); }
      bool same(ll x, ll y) { return root(x) == root(y); }
      bool same(pair<ll, ll> x) { return same(x.first, x.second); }
      T diff(ll x, ll y) { return weight(y) - weight(x); }
    };
    """

  'weightedunionfind':
    'prefix':'weightedunionfind'
    'body':'WeightedUnionfind<ll> u(n);'

  'LCA':
    'prefix':'LCA'
    'body':"""
    struct LCA {
      vector<vector<ll>> par;
      vector<ll> di, order, tsiz;
      LCA(graph &g, ll r = 0) { ini(g, r); }
      void ini(graph &g, ll r = 0) {
        ll s = g.size(), h = 1;
        while((1LL << h) < s) {h++;}
        par.assign(h, vector<ll>(s, -1));
        di.assign(s, -1);
        tsiz.resize(s);
        dfs(g, r, -1, 0);
        for(ll i = 0; i < h - 1; i++) {
          for(ll j = 0; j < s; j++) {
            if(par[i][j] < 0) {par[i + 1][j] = -1;}
            else {par[i + 1][j] = par[i][par[i][j]];}
          }
        }
      }
      void dfs(graph &g, ll v, ll p, ll d) {
        par[0][v] = p;
        di[v] = d;
        order.emplace_back(v);
        for(auto &nv : g[v]) {
          if(nv != p) {dfs(g, nv, v, d + 1);}
        }
        // tsiz[v] = 1; for(auto &nv : g[v]) {if(nv != p) {tsiz[v] += tsiz[nv];}}
      }
      ll lca(ll x, ll y) {
        if(di[x] < di[y]) swap(x, y);
        ll k = par.size();
        for(ll i = 0; i < k; i++) {
          if((di[x] - di[y]) >> i & 1) {x = par[i][x];}
        }
        if(x == y) return x;
        for(ll i = k - 1; i >= 0; i--) {
          if(par[i][x] != par[i][y]) {x = par[i][x], y = par[i][y];}
        }
        return par[0][x];
      }
      ll dis(ll x, ll y) { return di[x] + di[y] - 2 * di[lca(x, y)]; }
      bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }
      ll operator()(ll x, ll y) { return dis(x, y); }
      bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }
    };
    // depends on : graph
    """

  'LCA_w':
    'prefix':'LCA_w'
    'body':"""
    template<typename T> struct LCA {
      vector<vector<ll>> par;
      vector<ll> di, order, tsiz;
      vector<T> DI;
      LCA(vector<vector<pair<ll,T>>> &g, ll r = 0) { ini(g, r); }
      void ini(vector<vector<pair<ll,T>>> &g, ll r = 0) {
        ll s = g.size(), h = 1;
        while((1LL << h) < s) {h++;}
        par.assign(h, vector<ll>(s, -1));
        di.assign(s, -1);
        DI.assign(s, -1);
        tsiz.resize(s);
        dfs(g, r, -1, 0, 0);
        for(ll i = 0; i < h - 1; i++) {
          for(ll j = 0; j < s; j++) {
            if(par[i][j] < 0) {par[i + 1][j] = -1;}
            else {par[i + 1][j] = par[i][par[i][j]];}
          }
        }
      }
      void dfs(vector<vector<pair<ll,T>>> &g, ll v, ll p, ll d, T D) {
        par[0][v] = p;
        di[v] = d;
        DI[v] = D;
        order.emplace_back(v);
        for(auto &nv : g[v]) {
          if(nv.first != p) {dfs(g, nv.first, v, d + 1, D + nv.second);}
        }
        // tsiz[v]=1; for(auto &nv:g[v]) {if(nv.first!=p){ tsiz[v]+=tsiz[nv.first];}}
      }
      ll lca(ll x, ll y) {
        if(di[x] < di[y]) {swap(x, y);}
        ll k = par.size();
        for(ll i = 0; i < k; i++) {
          if((di[x] - di[y]) >> i & 1) {x = par[i][x];}
        }
        if(x == y) {return x;}
        for(ll i = k - 1; i >= 0; i--) {
          if(par[i][x] != par[i][y]){ x = par[i][x], y = par[i][y];}
        }
        return par[0][x];
      }
      T dis(ll x, ll y) { return DI[x] + DI[y] - 2 * DI[lca(x, y)]; }
      bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }
      T operator()(ll x, ll y) { return dis(x, y); }
      bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }
    };
    // depends on : weighted_graph

    """

  'SUM2D':
    'prefix':'SUM2D'
    'body':"""
    template<typename T> struct SUM2D {
      vector<vector<T>> D;
      SUM2D(ll H, ll W) { D.assign(H + 1, vector<T>(W + 1, 0)); }
      SUM2D(vector<vector<T>> &v) {
        ll H = v.size(), W = v[0].size();
        D.assign(H + 1, vector<T>(W + 1, T(0)));
        for(ll i = 0; i < H; i++) {
          for(ll j = 0; j < W; j++) {D[i + 1][j + 1] += v[i][j];}
        }
        build();
      }
      void add(ll x, ll y, T z) {
        x++, y++;
        D[x][y] += z;
      }
      void imos_add(ll x1, ll y1, ll x2, ll y2, T z) {
        x2++, y2++;
        add(x1, y1, z), add(x2, y2, z), add(x1, y2, -z), add(x2, y1, -z);
      }
      void operator()(ll x, ll y, T z) { add(x, y, z); }
      void operator()(ll x1, ll y1, ll x2, ll y2, T z) { imos_add(x1, y1, x2, y2, z); }
      void build() {
        for(ll i = 1; i < (ll)D.size(); i++) {
          for(ll j = 1; j < (ll)D[0].size(); j++) {D[i][j] += D[i - 1][j] + D[i][j - 1] - D[i - 1][j - 1];}
        }
      }
      void operator()() { build(); }
      T sum(ll x1, ll y1, ll x2, ll y2) {
        x2++, y2++;
        return D[x2][y2] - D[x1][y2] - D[x2][y1] + D[x1][y1];
      }
      T operator()(ll x1, ll y1, ll x2, ll y2) { return sum(x1, y1, x2, y2); }
      T operator()(pair<ll, ll> s, pair<ll, ll> t) { return sum(s.first, s.second, t.first, t.second); }
      vector<vector<T>> imos() { return D; }
      // 全て閉区間, 0-indexed
      // imosとsumの併用不可
      // add/imos_add -> build -> sum/imos の順番のみ使用可能
    };
    """

  'sum2d':
    'prefix':'sum2d'
    'body':'SUM2D<ll> S($1);'

  'BIT':
    'prefix':'BIT'
    'body':"""
    template<typename T> struct BIT {
      vector<T> v;
      ll n;
      bool imos;
      BIT(ll n_, bool imos_ = 0): v(n_ + 1, 0), n(n_ + 1), imos(imos_) {}
      BIT(vector<T> &a, bool imos_ = 0): v(a.size() + 1, 0), n(v.size()), imos(imos_) {
        if(!imos) {
          for(ll i = 0; i < a.size(); i++) {add(i, a[i]);}
        }
        else {
          for(ll i = 0; i < a.size(); i++) {imos_add(i, a[i]);}
        }
      }
      void add(ll i, T x) {
        for(i++; i < n; i += (i & -i)) {v[i] += x;}
      }
      void imos_add(ll l, ll r, T x) {
        imos = true;
        add(l, x), add(r + 1, -x);
      }
      void imos_add(ll i, T x) { imos_add(i, i, x); }
      T sum(ll r) {  // sum[0,r] imos:v[r]
        T re = T();
        for(r++; r > 0; r -= (r & -r)) {re += v[r];}
        return re;
      }
      T sum(ll l, ll r) { return sum(r) - sum(l - 1); }  // sum[l,r]
      T operator()(ll r) { return sum(r); }
      T operator()(ll l, ll r) { return sum(l, r); }
      T operator[](ll i) { return imos ? sum(i) : sum(i) - sum(i - 1); }
      ll LB(T x) {  // sum[0,i]<xとなるiの個数 / sum[0,i]>=xとなる最小のi
        ll i = 0;
        for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {
          if(i + k < n && v[i + k] < x) {
            x -= v[i + k];
            i += k;
          }
        }
        return i;
      }
      ll UB(T x) {  // sum[0,i]<=xとなるiの個数 / sum[0,i]>xとなる最小のi
        ll i = 0;
        for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {
          if(i + k < n && v[i + k] <= x) {
            x -= v[i + k];
            i += k;
          }
        }
        return i;
      }
    };
    """

  'BIT_':
    'prefix':'bit'
    'body':'BIT<ll> b(n);'

  'BIT2D':
    'prefix':'BIT2D'
    'body':"""
    template<typename T> struct BIT2D {
      ll H, W;
      vector<vector<T>> bit;
      bool imos;
      BIT2D(ll h, ll w, bool imos_ = 0): H(h + 1), W(w + 1), imos(imos_) { bit.resize(H + 3, vector<T>(W + 3, T(0))); };
      BIT2D(vector<vector<T>> v, bool imos_ = 0): H(v.size()), W(v[0].size()), imos(imos_) {
        bit.resize(H + 3, vector<T>(W + 3, T(0)));
        if(!imos) {
          for(ll i = 0; i < H; i++) {
            for(ll j = 0; j < W; j++) {add(i, j, v[i][j]);}
          }
        }
        else {
          for(ll i = 0; i < H; i++) {
            for(ll j = 0; j < W; j++) {imos_add(i, j, v[i][j]);}
          }
        }
      };
      void add(ll x, ll y, T w) {
        if(x < 0 || y < 0 || x >= H || y >= W) {return;}
        for(ll a = (++y, ++x); a <= H; a += a & -a) {
          for(ll b = y; b <= W; b += b & -b) {bit[a][b] += w;}
        }
      }
      void imos_add(ll x1, ll y1, ll x2, ll y2, T w) {
        imos = 1;
        x2++, y2++;
        add(x1, y1, w), add(x1, y2, -w), add(x2, y1, -w), add(x2, y2, w);
      }
      void imos_add(ll x, ll y, T w) { imos_add(x, y, x, y, w); }
      T sum(ll x, ll y) {  // sum[(0,0),(x,y)] imos:(x,y)
        if(x < 0 || y < 0) {return T(0);}
        if(x >= H) {x = H - 1;}
        if(y >= W) {y = W - 1;}
        T r = 0;
        for(ll a = (++y, ++x); a > 0; a -= a & -a) {
          for(ll b = y; b > 0; b -= b & -b) {r += bit[a][b];}
        }
        return r;
      }
      T sum(ll x1, ll y1, ll x2, ll y2) {
        if(x1 > x2 || y1 > y2) {return T(0);}
        x1--, y1--;
        return sum(x2, y2) - sum(x2, y1) - sum(x1, y2) + sum(x1, y1);
      }
      // 0-indexed
    };
    """

  'bit2d':
    'prefix':'bit2d'
    'body':'BIT2D<ll> B(h,w);'

  'Segtree':
    'prefix':'Segtree'
    'body':"""
    using S = ll;
    // struct S{};
    S op(S l, S r) { return $1; }
    S e() { return $2; }
    S tar;
    bool F(S x) { return $3; }

    /*
    void seg.set(i,x);   -> a[i] = x;
    T    seg.get(i);     -> return a[i];
    T    seg.prod(l,r)   -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()  -> return op(a[0], ... , a[n - 1]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */
    """

  'segtree':
    'prefix':'segtree'
    'body':'segtree<S,op,e> seg($1);'

  'Lazy_add_min':
    'prefix':'Lazy_add_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return f+x;}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_add_max':
    'prefix':'Lazy_add_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return f+x;}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_add_sum':
    'prefix':'Lazy_add_sum'
    'body':"""
    struct S{ll val,siz;};
    using F = ll;
    S op(S l,S r){return {l.val+r.val,l.siz+r.siz};}
    S e(){return {0,0};}
    S fx(F f,S x){return {x.val+f*x.siz,x.siz};}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    // V<S> a(n,{0,1});

    """

  'Lazy_update_min':
    'prefix':'Lazy_update_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return (f==1e18?x:f);}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_update_max':
    'prefix':'Lazy_update_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return (f==1e18?x:f);}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_update_sum':
    'prefix':'Lazy_update_sum'
    'body':"""
    struct S{ll val,siz;};
    using F = ll;
    S op(S l,S r){return {l.val+r.val,l.siz+r.siz};}
    S e(){return {0,0};}
    S fx(F f,S x){if(f!=1e18) x.val=f*x.siz; return x;}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    // V<S> a(n,{0,1});

    """

  'Lazy_chmax_min':
    'prefix':'Lazy_chmax_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return max(f,x);}
    F fg(F f,F g){return max(f,g);}
    F id(){return -1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmax_max':
    'prefix':'Lazy_chmax_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return max(f,x);}
    F fg(F f,F g){return max(f,g);}
    F id(){return -1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmin_min':
    'prefix':'Lazy_chmin_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return min(f,x);}
    F fg(F f,F g){return min(f,g);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmin_max':
    'prefix':'Lazy_chmin_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return min(f,x);}
    F fg(F f,F g){return min(f,g);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_void':
    'prefix':'Lazy_void'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S a,S b){return ;}
    S e(){return ;}
    S fx(F f,S x){return ;}
    F fg(F f,F g){return ;}
    F id(){return ;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'lazy_segtree':
    'prefix':'lazy_segtree'
    'body':'lazy_segtree<S,op,e,F,fx,fg,id> seg($1);'

  'Mo':
    'prefix':'Mo'
    'body':"""
    struct Mo {
      ll W;
      vector<ll> L, R, O;
      Mo(ll N, ll Q): O(Q) {
        W = max<ll>(1LL, 1.0 * N / max<long double>(1.0, sqrt(Q * 2.0 / 3.0)));
        iota(O.begin(), O.end(), 0);
      }
      void operator()(ll l, ll r) {  // [l,r)
        L.emplace_back(l);
        R.emplace_back(r);
      }
      template<typename AL, typename AR, typename DL, typename DR, typename REM>
      void solve(const AL &add_l, const AR &add_r, const DL &del_l, const DR &del_r, const REM &rem) {
        sort(O.begin(), O.end(), [&](ll a, ll b) {
          ll A = L[a] / W, B = L[b] / W;
          if(A != B) {return A < B;}
          if(A & 1) {return R[a] < R[b];}
          return R[a] > R[b];
        });
        ll nl = 0, nr = 0;
        for(auto i : O) {
          while(nl > L[i]) {add_l(--nl);}
          while(nr < R[i]) {add_r(nr++);}
          while(nl < L[i]) {del_l(nl++);}
          while(nr > R[i]) {del_r(--nr);}
          rem(i);
        }
      }
      template<typename AL, typename AR, typename DL, typename DR, typename REM>
      void operator()(const AL &add_l, const AR &add_r, const DL &del_l, const DR &del_r, const REM &rem) { solve(add_l, add_r, del_l, del_r, rem); }
      template<typename A, typename D, typename REM>
      void operator()(const A &add, const D &del, const REM &rem) { solve(add, add, del, del, rem); }
    };

    auto add = [&](ll i) {};
    auto del = [&](ll i) {};
    auto rem = [&](ll i) {};
    // main の中に入れる
    """

  'Geometry':
    'prefix':'Geometry'
    'body':"""
    constexpr long double EPS = 1e-10, PI = acos(-1);
    template<typename T> ll sign(const T &r) { return r <= -EPS ? -1 : r >= EPS ? 1
                                                                                : 0; }
    bool EQ(const long double &a, const long double &b = 0.0) { return sign(a - b) == 0; }
    using Real = long double;
    Real rtod(Real r) { return r * 180.0 / PI; }
    Real dtor(Real d) { return d * PI / 180.0; }
    using Point = complex<Real>;
    istream &operator>>(istream &is, Point &p) {
      long double a, b;
      cin >> a >> b;
      p = Point(a, b);
      return is;
    }
    ostream &operator<<(ostream &os, const Point &p) { return os << real(p) << " " << imag(p); }
    Point operator*(const Point &p, const Real &d) { return Point(real(p) * d, imag(p) * d); }
    Point operator/(const Point &p, const Real &d) { return Point(real(p) / d, imag(p) / d); }
    Point operator*=(Point &p, const Real &d) { return p = p * d; }
    Point operator/=(Point &p, const Real &d) { return p = p / d; }
    Point rotate(const Point &p, Real theta) { return Point(cos(theta) * real(p) - sin(theta) * imag(p), sin(theta) * real(p) + cos(theta) * imag(p)); }
    Real angle(const Point &a, const Point &b, const Point &c) {  // ∠ABC（鋭角）
      const Point v(a - b), w(c - b);
      auto t1 = atan2(imag(v), real(v)), t2 = atan2(imag(w), real(w));
      if(t1 > t2) {swap(t1, t2);}
      Real theta = t2 - t1;
      return min(theta, 2 * PI - theta);
    }
    Real cross(const Point &a, const Point &b) { return real(a) * imag(b) - imag(a) * real(b); }  // 外積 |a||b|sinθ
    Real dot(const Point &a, const Point &b) { return real(a) * real(b) + imag(a) * imag(b); }  // 内積 |a||b|cosθ
    Real operator^(const Point &a, const Point &b) { return cross(a, b); }
    Real operator*(const Point &a, const Point &b) { return dot(a, b); }
    Point unit(const Point &p) { return p / abs(p); }  // 単位ベクトル
    bool compare_x(const Point &a, const Point &b) { return EQ(real(a), real(b)) ? imag(a) < imag(b) : real(a) < real(b); }
    bool compare_y(const Point &a, const Point &b) { return EQ(imag(a), imag(b)) ? real(a) < real(b) : imag(a) < imag(b); }
    namespace std {
    bool operator<(const Point &a, const Point &b) { return compare_x(a, b); }
    }  // namespace std
    struct Line {
      Point a, b;
      Line() = default;
      Line(const Point &a, const Point &b): a(a), b(b) {}
      Line(const Real &A, const Real &B, const Real &C) {  // Ax+By=C
        if(EQ(A)) {
          assert(!EQ(B));
          a = Point(0, C / B);
          b = Point(1, C / B);
        }
        else if(EQ(B)) {a = Point(C / A, 0), b = Point(C / A, 1);}
        else {a = Point(0, C / B), b = Point(C / A, 0);}
      }
      Point operator()() const { return b - a; }  // 方向ベクトル
      friend istream &operator>>(istream &is, Line &l) { return is >> l.a >> l.b; }
      friend ostream &operator<<(ostream &os, Line &l) { return os << l.a << " to " << l.b; }
    };
    struct Segment : Line {
      Segment() = default;
      using Line::Line;
    };
    struct Circle {
      Point p;
      Real r{};
      Circle() = default;
      Circle(const Point &p, const Real &r): p(p), r(r) {}
      friend istream &operator>>(istream &is, Circle &c) { return is >> c.p >> c.r; }
      friend ostream &operator<<(ostream &os, Circle &c) { return os << c.p << " ," << c.r; }
    };
    using Points = vector<Point>;
    using Polygon = vector<Point>;
    using Polygons = vector<Polygon>;
    using Lines = vector<Line>;
    using Segments = vector<Segment>;
    using Circles = vector<Circle>;
    ll ccw(const Point &a, Point b, Point c) {
      b = b - a, c = c - a;
      if(sign(b ^ c) == +1) {return +1;}  // a,b,c がこの順で反時計回り
      if(sign(b ^ c) == -1) {return -1;}  // a,b,c がこの順で時計回り
      if(sign(b * c) == -1) {return +2;}  // c-a-b
      if(norm(b) < norm(c)) {return -2;}  // a-b-c
      return 0;  // a-c-b
    }
    bool parallel(const Line &a, const Line &b) { return EQ(a() ^ b()); }
    bool orthogonal(const Line &a, const Line &b) { return EQ(a() * b()); }
    bool operator|(const Line &a, const Line &b) { return parallel(a, b); }
    bool operator+(const Line &a, const Line &b) { return orthogonal(a, b); }
    Point projection(const Line &l, const Point &p) {  // pからlに下した垂線の足
      auto t = (p - l.a) * (l.a - l.b) / norm(l.a - l.b);
      return l.a + (l.a - l.b) * t;
    }
    Point reflection(const Line &l, const Point &p) { return projection(l, p) * 2 - p; }  // lに関してpと対称な点
    ll intersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1 ? 1 : 0; }
    ll intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0 ? 1 : 0; }
    ll intersect(const Circle &c, const Point &p) { return EQ(abs(p - c.p), c.r) ? 1 : 0; }
    ll intersect(const Line &a, const Line &b) { return a | b ? abs(ccw(a.a, a.b, b.a)) == 1 ? 0 : 2 : 1; }  // 0:平行 1:交差 2:一致
    ll intersect(const Line &l, const Segment &s) { return sign(l() ^ (s.a - l.a)) * sign(l() ^ (s.b - l.a)) <= 0 ? 1 : 0; }
    ll intersect(const Segment &a, const Segment &b) { return ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) <= 0 && ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) <= 0 ? 1 : 0; }
    ll intersect(const Circle &c, const Line &l) { return sign(c.r - abs(c.p - projection(l, c.p))) + 1; }
    ll intersect(const Circle &c, const Segment &s) {
      ll r = intersect(c, Line(s)), f = ccw(s.a, s.b, projection(s, c.p));
      if(r == 0) {return 0;}
      if(r == 1) {return f == 0 ? 1 : 0;}
      ll f1 = sign(abs(c.p - s.a) - c.r), f2 = sign(abs(c.p - s.b) - c.r);
      if(f1 < 0 && f2 < 0) {return 0;}
      if(f1 < 0 || f2 < 0) {return 1;}
      if(f1 == 0 && f2 == 0) {return 2;}
      if(f1 == 0 || f2 == 0) {return f == 0 ? 2 : 1;}
      return f == 0 ? 2 : 0;
    }
    ll intersect(const Circle &a, const Circle &b) {  // +2:外部 -2:内部 +1:外接 -1:内接 0:2点で交わる
      Real d = abs(a.p - b.p), R = a.r + b.r, r = fabs(a.r - b.r);
      if(sign(d - R) > 0) {return +2;}
      if(sign(d - r) < 0) {return -2;}
      if(EQ(d, R)) {return +1;}
      if(EQ(d, r)) {return -1;}
      return 0;
    }
    template<typename T, typename U> ll operator&(const T &a, const U &b) { return intersect(a, b); }
    Real distance(const Point &a, const Point &b) { return abs(a - b); }
    Real distance(const Line &l, const Point &p) { return abs(p - projection(l, p)); }
    Real distance(const Line &a, const Line &b) { return a & b ? 0 : distance(a, b.a); }
    Real distance(const Line &l, const Segment &s) { return l & s ? 0 : min(distance(l, s.a), distance(l, s.b)); }
    Real distance(const Segment &s, const Point &p) { return s & projection(s, p) ? abs(projection(s, p) - p) : min(abs(s.a - p), abs(s.b - p)); }
    Real distance(const Segment &a, const Segment &b) { return a & b ? 0 : min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)}); }
    template<typename T, typename U> Real operator%(const T &a, const U &b) { return distance(a, b); }
    Point crosspoint(const Line &l, const Line &m) {
      Real A = cross(l.b - l.a, m.b - m.a);
      Real B = cross(l.b - l.a, l.b - m.a);
      if(EQ(abs(A), 0) && EQ(abs(B), 0)) {return m.a;}
      return m.a + (m.b - m.a) * B / A;
    }
    Points crosspoint(const Circle &c, const Line &l) {
      Point h = projection(l, c.p), e = unit(l());
      if((c & l) == 0) {return {};}
      if((c & l) == 1) {return {h};}
      auto k = sqrt(norm(c.r) - norm(h - c.p));
      return {h - e * k, h + e * k};
    }
    Points crosspoint(const Circle &c, const Segment &s) {
      if((c & s) == 0) {return {};}
      auto r = crosspoint(c, Line(s));
      if((c & s) == 2) {return r;}
      if((s.a - r[0]) * (s.b - r[0]) > 0) {swap(r[0], r[1]);}
      return {r[0]};
    }
    Points crosspoint(const Circle &a, const Circle &b) {
      if(abs(a & b) == 2) return {};
      Real d = abs(a.p - b.p), t = acos((a.r * a.r - b.r * b.r + d * d) / (2 * a.r * d)), s = arg(b.p - a.p);
      Point p = a.p + polar(a.r, s + t), q = a.p + polar(a.r, s - t);
      if(abs(a & b) == 1) {return {p};}
      return {p, q};
    }
    Point operator*(const Line &a, const Line &b) { return crosspoint(a, b); }
    template<typename T> Points operator*(const Circle &c, const T &x) { return crosspoint(c, x); }
    Points tangent(const Circle &c, const Point &p) {
      if(sign(abs(p - c.p) - c.r) < 0) {return {};}
      if(EQ(abs(p - c.p), c.r)) {return {p};}
      return c * Circle(p, sqrt(norm(p - c.p) - c.r * c.r));
    }
    Lines tangent(Circle &a, Circle &b) {
      Lines ret;
      if(sign(a.r - b.r) < 0) swap(a, b);
      Real g = norm(a.p - b.p);
      if(EQ(g)) return ret;
      Point u = (b.p - a.p) / sqrt(g), v = rotate(u, PI * 0.5);
      for(ll s : {-1, 1}) {
        Real h = (a.r + s * b.r) / sqrt(g);
        if(EQ(1 - h * h)) {ret.push_back(Line(a.p + u * a.r, a.p + (u + v) * a.r));}
        else if(sign(1 - h * h) > 0) {
          Point uu = u * h, vv = v * sqrt(1 - h * h);
          ret.push_back(Line(a.p + (uu + vv) * a.r, b.p - (uu + vv) * b.r * s));
          ret.push_back(Line(a.p + (uu - vv) * a.r, b.p - (uu - vv) * b.r * s));
        }
      }
      return ret;
    }
    bool is_convex(const Polygon &p) {
      ll n = p.size();
      for(ll i = 0; i < n; i++){
        if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) {return false;}
      }
      return true;
    }
    Polygon convex_hull(Polygon &p, bool strict = 1) {
      ll n = p.size(), k = 0;
      if(n <= 2) return p;
      sort(begin(p), end(p), compare_x);
      Points ch(2 * n);
      auto check = [&](ll i) { return sign((ch[k - 1] - ch[k - 2]) ^ (p[i] - ch[k - 1])) <= -1 + strict; };
      for(ll i = 0; i < n; ch[k++] = p[i++]){
        while(k >= 2 && check(i)) {--k;}
      }
      for(ll i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){
        while(k >= t && check(i)) {--k;}
      }
      ch.resize(k - 1);
      return ch;
    }
    ll contains(const Polygon &Q, const Point &p) {  // 0:OUT 1:ON 2:IN
      bool in = 0;
      for(ll i = 0; i < Q.size(); i++) {
        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;
        if(imag(a) > imag(b)) {swap(a, b);}
        if(sign(imag(a)) <= 0 && 0 < sign(imag(b)) && sign(a ^ b) < 0) {in = !in;}
        if(EQ(a ^ b) && sign(a * b) <= 0) {return 1;}
      }
      return in ? 2 : 0;
    }
    ll convex_contains(const Polygon &Q, const Point &p) {  // 0:OUT 1:ON 2:IN
      ll N = Q.size();
      Point g = (Q[0] + Q[N / 3] + Q[N * 2 / 3]) / 3.0;
      if(EQ(imag(g), imag(p)) && EQ(real(g), real(p))) {return 2;}
      Point gp = p - g;
      ll l = 0, r = N;
      while(r - l > 1) {
        ll mid = (l + r) / 2;
        Point gl = Q[l] - g, gm = Q[mid] - g;
        if((gl ^ gm) > 0) {(gl ^ gp) >= 0 && (gm ^ gp) <= 0 ? r = mid : l = mid;}
        else {(gl ^ gp) <= 0 && (gm ^ gp) >= 0 ? l = mid : r = mid;}
      }
      r %= N;
      Real v = (Q[l] - p) ^ (Q[r] - p);
      return sign(v) == 0 ? 1 : sign(v) == -1 ? 0
                                              : 2;
    }
    void merge_segments(Segments &segs) {
      auto merge_if_able = [](Segment &s1, const Segment &s2) {
        if(sign((s1.b - s1.a) ^ (s2.b - s2.a)) == 1) {return 0;}
        if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) {return 0;}
        if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) {return 0;}
        s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));
        return 1;
      };
      for(ll i = 0; i < segs.size(); i++) {
        if(segs[i].b < segs[i].a) {swap(segs[i].a, segs[i].b);}
      }
      for(ll i = 0; i < segs.size(); i++) {
        for(ll j = i + 1; j < segs.size(); j++) {
          if(merge_if_able(segs[i], segs[j])) {segs[j--] = segs.back(), segs.pop_back();}
        }
      }
    }
    vector<vector<ll>> segment_arrangement(Segments &segs, Points &ps) {
      vector<vector<ll>> g;
      ll N = segs.size();
      for(ll i = 0; i < N; i++) {
        ps.push_back(segs[i].a);
        ps.push_back(segs[i].b);
        for(ll j = i + 1; j < N; j++) {
          const Point p1 = segs[i].b - segs[i].a, p2 = segs[j].b - segs[j].a;
          if((p1 ^ p2) == 0) {continue;}
          if(intersect(segs[i], segs[j])) {ps.push_back(crosspoint(segs[i], segs[j]));}
        }
      }
      sort(ps.begin(), ps.end());
      ps.erase(unique(ps.begin(), ps.end()), ps.end());
      ll M = ps.size();
      g.resize(M);
      for(ll i = 0; i < N; i++) {
        vector<ll> v;
        for(ll j = 0; j < M; j++){
          if(intersect(segs[i], ps[j])) {v.push_back(j);}
        }
        for(ll j = 1; j < v.size(); j++) {g[v[j - 1]].push_back(v[j]), g[v[j]].push_back(v[j - 1]);}
      }
      return g;
    }
    Polygon convex_cut(const Polygon &U, const Line &l) {
      Polygon ret;
      for(ll i = 0; i < U.size(); i++) {
        const Point &now = U[i], &nxt = U[(i + 1) % U.size()];
        auto cf = (l.a - now) ^ (l.b - now), cs = (l.a - nxt) ^ (l.b - nxt);
        if(sign(cf) >= 0) {ret.push_back(now);}
        if(sign(cf) * sign(cs) < 0) {ret.push_back(Line(now, nxt) * l);}
      }
      return ret;
    }
    pair<ll, ll> convex_diameter(const Polygon &p) {
      ll N = p.size(), is = 0, js = 0;
      for(ll i = 1; i < N; i++) {
        if(imag(p[i]) > imag(p[is])) {is = i;}
        if(imag(p[i]) < imag(p[js])) {js = i;}
      }
      Real maxdis = norm(p[is] - p[js]);
      ll maxi, maxj, i, j;
      i = maxi = is;
      j = maxj = js;
      do {
        ((p[(i + 1) % N] - p[i]) ^ (p[(j + 1) % N] - p[j])) >= 0 ? j = (j + 1) % N : i = (i + 1) % N;
        if(norm(p[i] - p[j]) > maxdis) {
          maxdis = norm(p[i] - p[j]);
          maxi = i;
          maxj = j;
        }
      } while(i != is || j != js);
      return minmax(maxi, maxj);
    }
    Real area(const Polygon &p) {
      ll n = p.size();
      Real A = 0;
      for(ll i = 0; i < n; i++) {{A += (p[i] ^ p[(i + 1) % n]);}}
      return abs(A * 0.5);
    }
    Real ca_cp_impl(const Circle &c, const Point &a, const Point &b) {
      auto va = c.p - a, vb = c.p - b;
      Real f = va ^ vb, ret = 0;
      if(sign(f) == 0) {return ret;}
      if(sign(max(abs(va), abs(vb)) - c.r) <= 0) {return f;}
      if(sign((Segment(a, b) % c.p) - c.r) >= 0) {return norm(c.r) * arg(vb * conj(va));}
      auto tot = c * Line(a, b);
      if((c & Segment(a, b)) != 2 && (a - tot[0]) * (b - tot[0]) < 0) {swap(tot[0], tot[1]);}
      tot.emplace(begin(tot), a);
      tot.emplace_back(b);
      for(ll i = 1; i < tot.size(); i++) {ret += ca_cp_impl(c, tot[i - 1], tot[i]);}
      return ret;
    }
    Real area(const Circle &c, const Polygon &p) {
      if(p.size() < 3) {return 0;}
      Real A = 0;
      for(ll i = 0; i < p.size(); i++) {A += ca_cp_impl(c, p[i], p[(i + 1) % p.size()]);}
      return A * 0.5;
    }
    Real closest_pair(Points ps) {
      if(ps.size() <= 1) throw(0);
      sort(ps.begin(), ps.end());
      auto compare_Y = [&](const Point &a, const Point &b) { return imag(a) < imag(b); };
      Points beet(ps.size());
      const Real Inf = 1e18;
      function<Real(ll, ll)> rec = [&](ll left, ll right) {
        if(right - left <= 1) {return Inf;}
        ll mid = (left + right) >> 1;
        auto x = real(ps[mid]);
        auto ret = min(rec(left, mid), rec(mid, right));
        inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_Y);
        ll ptr = 0;
        for(ll i = left; i < right; i++) {
          if(abs(real(ps[i]) - x) >= ret) {continue;}
          for(ll j = 0; j < ptr; j++) {
            auto luz = ps[i] - beet[ptr - j - 1];
            if(imag(luz) >= ret) {break;}
            ret = min(ret, abs(luz));
          }
          beet[ptr++] = ps[i];
        }
        return ret;
      };
      return rec(0, ps.size());
    }
    """

  'Eratosthenes':
    'prefix':'Eratosthenes'
    'body':"""
    vector<bool> Eratosthenes(int n) {
      vector<bool> prime(n + 1, true);
      if(n >= 0) { prime[0] = false; }
      if(n >= 1) { prime[1] = false; }
      for(int i = 2; i * i <= n; i++) {
        if(!prime[i]) { continue; }
        for(int j = i + i; j <= n; j += i) { prime[j] = false; }
      }
      return prime;
    }
    """

  'Eratosthenes_':
    'prefix':'Eratosthenes_'
    'body':"""
    //  is_p[i].empty() -> i は素数
    // !is_p[i].empty() -> is_p[i] は i の素因数を格納
    // 素数判定の必要なし，素因数だけ欲しいときは j=i*2 を j=i に変更
    // p : n以下の素数列

    pair<vector<vector<ll>>, vector<ll>> Eratosthenes(ll n) {
      vector<vector<ll>> is_p(n + 1);
      vector<ll> p;
      for(ll i = 2; i <= n; i++) {
        if(!is_p[i].empty()) {continue;}
        p.push_back(i);
        for(ll j = i ; j <= n; j += i) {is_p[j].emplace_back(i);}
      }
      return {is_p, p};
    }
    """

  'eratosthenes':
    'prefix':'eratosthenes'
    'body':'Eratosthenes($1);'

  'prime_super':
    'prefix':'Prime_super'
    'body':"""
    bool is_prime(ll x) {
      if(x == 2 || x == 3 || x == 5 || x == 7) { return true; }
      if(x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) { return false; }
      if(x < 121) { return x > 1; }
      ll d = (x - 1) >> __builtin_ctzll(x - 1);
      ll p = 1, m = x - 1;
      auto internal_pow = [](ll x, ll n, ll mod) {
        __uint128_t r;
        x %= mod;
        if(n == 0) {
          r = 1;
          return r;
        }
        r = 1;
        __uint128_t c = x;
        for(; n; n >>= 1, c = (c * c) % mod) {
          if(n & 1) { r = r * c % mod; }
        }
        return r;
      };
      auto ok = [&](ll a) {
        auto y = internal_pow(a, d, x);
        ll t = d;
        while(y != p && y != m && t != x - 1) {
          y = y * y % x;
          t <<= 1;
        }
        if(y != m && t % 2 == 0) { return false; }
        return true;
      };
      if(x < (1ll << 32)) {
        for(ll a : {2, 7, 61}) {
          if(!ok(a)) { return false; }
        }
      }
      else {
        for(ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {
          if(x <= a) { return true; }
          if(!ok(a)) { return false; }
        }
      }
      return true;
    }
    ll Rho(ll n) {
      if(n % 2 == 0) {return 2;}
      if(is_prime(n)) {return n;}
      auto f = [&](ll x) -> ll { return (__int128_t(x) * x + 1) % n; };
      ll step = 0;
      while(1) {
        ++step;
        ll x = step, y = f(x);
        while(true) {
          ll p = gcd(y - x + n, n);
          if(p == 0 || p == n) {break;}
          if(p != 1) {return p;}
          x = f(x);
          y = f(f(y));
        }
      }
    }
    vector<ll> PrimeFactorize(ll n) {
      if(n == 1) {return {};}
      ll p = Rho(n);
      if(p == n) {return {p};}
      vector<ll> left = PrimeFactorize(p), right = PrimeFactorize(n / p);
      left.insert(left.end(), right.begin(), right.end());
      ranges::sort(left);
      return left;
    }
    """

  'WaveletMatrix':
    'prefix':'WaveletMatrix'
    'body':"""
    struct SuccinctIndexableDictionary {
      ll len;
      ll blk;
      vector<ll> bit, sum;
      SuccinctIndexableDictionary() = default;
      SuccinctIndexableDictionary(ll len): len(len), blk((len + 31) >> 5) {
        bit.assign(blk, 0LL);
        sum.assign(blk, 0LL);
      }
      void set(ll k) { bit[k >> 5] |= 1LL << (k & 31); }
      void build() {
        sum[0] = 0LL;
        for(ll i = 1; i < blk; i++) {sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);}
      }
      bool operator[](ll k) { return (bool((bit[k >> 5] >> (k & 31)) & 1)); }
      ll rank(ll k) { return (sum[k >> 5] + __builtin_popcountll(bit[k >> 5] & ((1LL << (k & 31)) - 1))); }
      ll rank(bool val, ll k) { return (val ? rank(k) : k - rank(k)); }
    };

    template<typename T, ll MAXLOG> struct WaveletMatrix {
      ll len;
      SuccinctIndexableDictionary mat[MAXLOG];
      ll mid[MAXLOG];
      WaveletMatrix() = default;
      WaveletMatrix(vector<T> v): len(v.size()) {
        vector<T> l(len), r(len);
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          mat[lev] = SuccinctIndexableDictionary(len + 1);
          ll left = 0, right = 0;
          for(ll i = 0; i < len; i++) {
            if(((v[i] >> lev) & 1)) {
              mat[lev].set(i);
              r[right++] = v[i];
            }
            else {l[left++] = v[i];}
          }
          mid[lev] = left;
          mat[lev].build();
          v.swap(l);
          for(ll i = 0; i < right; i++) {v[left + i] = r[i];}
        }
      }
      pair<ll, ll> succ(bool f, ll l, ll r, ll lev) { return {mat[lev].rank(f, l) + mid[lev] * f, mat[lev].rank(f, r) + mid[lev] * f}; }
      T access(ll k) {
        T ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          bool f = mat[lev][k];
          if(f) {ret |= T(1) << lev;}
          k = mat[lev].rank(f, k) + mid[lev] * f;
        }
        return ret;
      }
      T operator[](const ll &k) { return access(k); }
      ll rank(const T &x, ll r) {
        ll l = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {tie(l, r) = succ((x >> lev) & 1, l, r, lev);}
        return r - l;
      }
      T kth_smallest(ll l, ll r, ll k) {
        assert(0 <= k && k < r - l);
        T ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          ll cnt = mat[lev].rank(false, r) - mat[lev].rank(false, l);
          bool f = cnt <= k;
          if(f) {
            ret |= T(1) << lev;
            k -= cnt;
          }
          tie(l, r) = succ(f, l, r, lev);
        }
        return ret;
      }
      T kth_largest(ll l, ll r, ll k) { return kth_smallest(l, r, r - l - k - 1); }
      ll range_freq(ll l, ll r, T upper) {
        ll ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          bool f = ((upper >> lev) & 1);
          if(f) {ret += mat[lev].rank(false, r) - mat[lev].rank(false, l);}
          tie(l, r) = succ(f, l, r, lev);
        }
        return ret;
      }
      ll range_freq(ll l, ll r, T lower, T upper) { return range_freq(l, r, upper) - range_freq(l, r, lower); }
      T prev_value(ll l, ll r, T upper) {
        ll cnt = range_freq(l, r, upper);
        return cnt == 0 ? T(-1) : kth_smallest(l, r, cnt - 1);
      }
      T next_value(ll l, ll r, T lower) {
        ll cnt = range_freq(l, r, lower);
        return cnt == r - l ? T(-1) : kth_smallest(l, r, cnt);
      }
    };

    template<typename T = ll, ll MAXLOG = 20> struct CompressedWaveletMatrix {
      WaveletMatrix<ll, MAXLOG> mat;
      vector<T> ys;
      CompressedWaveletMatrix(const vector<T> &v): ys(v) {
        ranges::sort(ys);
        ys.erase(unique(ys.begin(), ys.end()), ys.end());
        vector<ll> t(v.size());
        for(ll i = 0; i < (ll)v.size(); i++) {t[i] = get(v[i]);}
        mat = WaveletMatrix<ll, MAXLOG>(t);
      }
      inline ll get(const T &x) { return ranges::lower_bound(ys, x) - ys.begin(); }
      T access(ll k) { return ys[mat.access(k)]; }
      T operator[](const ll &k) { return access(k); }
      ll rank(const T &x, ll r) {  // count i s.t. (0<=i<r)&&v[i]==x
        auto pos = get(x);
        if(pos == (ll)ys.size() || ys[pos] != x) {return 0;}
        return mat.rank(pos, r);
      }
      ll count(ll l, ll r, T x) {  // count i s.t. (l<=i<r)&&v[i]==x
        if(l >= r) { return 0; }
        return rank(x, r) - rank(x, l);
      }
      T kth_smallest(ll l, ll r, ll k) { return ys[mat.kth_smallest(l, r, k)]; }  // k-th(0-indexed) smallest number in v[l,r)
      T kth_largest(ll l, ll r, ll k) { return ys[mat.kth_largest(l, r, k)]; }  // k-th(0-indexed) largest number in v[l,r)
      ll range_freq(ll l, ll r, T upper) {  // count i s.t. (l<=i<r)&&(v[i]<upper)
        if(l >= r) { return 0; }
        return mat.range_freq(l, r, get(upper));
      }
      ll range_freq(ll l, ll r, T lower, T upper) {  // count i s.t. (l<=i<r)&&(lower<=v[i]<upper)
        if(l >= r || lower >= upper) { return 0; }
        return mat.range_freq(l, r, get(lower), get(upper));
      }
      T prev_value(ll l, ll r, T upper) {  // max v[i] s.t. (l<=i<r)&&(v[i]<upper)
        auto ret = mat.prev_value(l, r, get(upper));
        return ret == -1 ? T(-1) : ys[ret];
      }
      T next_value(ll l, ll r, T lower) {  // min v[i] s.t. (l<=i<r)&&(lower<=v[i])
        auto ret = mat.next_value(l, r, get(lower));
        return ret == -1 ? T(-1) : ys[ret];
      }
    };
    """

  'waveletmatrix':
    'prefix':'waveletmatrix'
    'body':'CompressedWaveletMatrix<> W($1);'

  'PrioritySum':
    'prefix':'PrioritySum'
    'body':"""
    template<typename T, typename Compare = less<T>, typename RCompare = greater<T>> struct PrioritySum {
      ll k;
      T sum;
      priority_queue<T, vector<T>, Compare> in, d_in;
      priority_queue<T, vector<T>, RCompare> out, d_out;
      PrioritySum(int k): k(k), sum(0) {}
      void modify() {
        while(in.size() - d_in.size() < k && !out.empty()) {
          auto p = out.top();
          out.pop();
          if(!d_out.empty() && p == d_out.top()) {d_out.pop();}
          else {
            sum += p;
            in.emplace(p);
          }
        }
        while(in.size() - d_in.size() > k) {
          auto p = in.top();
          in.pop();
          if(!d_in.empty() && p == d_in.top()) {d_in.pop();}
          else {
            sum -= p;
            out.emplace(p);
          }
        }
        while(!d_in.empty() && in.top() == d_in.top()) {
          in.pop();
          d_in.pop();
        }
      }
      T query() const { return sum; }
      void insert(T x) {
        in.emplace(x);
        sum += x;
        modify();
      }
      void erase(T x) {
        assert(size());
        if(!in.empty() && in.top() == x) {
          sum -= x;
          in.pop();
        }
        else if(!in.empty() && RCompare()(in.top(), x)) {
          sum -= x;
          d_in.emplace(x);
        }
        else {d_out.emplace(x);}
        modify();
      }
      void set(ll kk) {
        k = kk;
        modify();
      }
      ll get() const { return k; }
      ll size() const { return in.size() + out.size() - d_in.size() - d_out.size(); }
      T operator()() { return query(); }
      void operator>>(T x) { insert(x); }
      void operator<<(T x) { erase(x); }
    };

    template<typename T> using MaxSum = PrioritySum<T, greater<T>, less<T>>;
    template<typename T> using MinSum = PrioritySum<T, less<T>, greater<T>>;
    """

  'MaxSum':
    'prefix':'MaxSum'
    'body':'MaxSum<ll> s($1);'

  'MinSum':
    'prefix':'MinSum'
    'body':'MinSum<ll> s($1);'

  'Matrix':
    'prefix':'Matrix'
    'body':"""
    template<typename T> struct Matrix : vector<vector<T>> {
      using vector<vector<T>>::vector;
      using vector<vector<T>>::operator=;
      Matrix() {}
      Matrix(int n) {
        this->assign(n, vector<T>(n, 0));
        for(ll i = 0; i < n; i++) {(*this)[i][i] = 1;}
      }
      Matrix(ll n, ll m, T x = 0) {
        for(ll i = 0; i < n; i++) {this->push_back(vector<T>(m, x));}
      }
      Matrix(vector<vector<T>> v) { *this = v; }
      Matrix operator+(const Matrix &m) const { return Matrix(*this) += m; }
      Matrix operator+(const T &x) const { return Matrix(*this) += x; }
      Matrix operator-(const Matrix &m) const { return Matrix(*this) -= m; }
      Matrix operator-(const T &x) const { return Matrix(*this) -= x; }
      Matrix operator*(const Matrix &m) const { return Matrix(*this) *= m; }
      Matrix operator*(const T &x) const { return Matrix(*this) *= x; }
      Matrix operator^(ll n) const { return Matrix(*this) ^= n; }
      Matrix operator+=(const Matrix &m) const {
        ll h = this->size(), w = (*this)[0].size();
        assert(h == m.size() && w == m[0].size());
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] += m[i][j]; }
        }
        return *this;
      }
      Matrix operator+=(const T &x) {
        ll h = this->size(), w = (*this)[0].size();
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] += x; }
        }
        return *this;
      }
      Matrix operator-=(const Matrix &m) {
        ll h = this->size(), w = (*this)[0].size();
        assert(h == m.size() && w == m[0].size());
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] -= m[i][j]; }
        }
        return *this;
      }
      Matrix operator-=(const T &x) {
        ll h = this->size(), w = (*this)[0].size();
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] -= x; }
        }
        return *this;
      }
      Matrix operator*=(const Matrix &m) {
        ll h = this->size(), w = (*this)[0].size();
        assert(w == m.size());
        vector<vector<T>> r(h, vector<T>(m[0].size(), T(0)));
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < (ll)m[0].size(); j++) {
            for(ll k = 0; k < w; k++) { r[i][j] += (*this)[i][k] * m[k][j]; }
          }
        }
        this->swap(r);
        return *this;
      }
      Matrix operator*=(const T &x) {
        ll h = this->size(), w = (*this)[0].size();
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] *= x; }
        }
        return *this;
      }
      Matrix operator^=(ll n) {
        int h = this->size();
        Matrix m(h);
        while(n) {
          if(n & 1) {m *= *this;}
          *this *= *this;
          n >>= 1LL;
        }
        this->swap(m);
        return *this;
      }
    };
    """

  'Matrix_linear':
    'prefix':'Matrix_linear'
    'body':"""
    Matrix<long double> rotate(const long double &theta) {
      Matrix<long double> r = {{cos(theta), -sin(theta)}, {sin(theta), cos(theta)}};
      return r;
    }
    Matrix<ll> rotate_left() {
      Matrix<ll> r = {{0, -1}, {1, 0}};
      return r;
    }
    Matrix<ll> rotate_right() {
      Matrix<ll> r = {{0, 1}, {-1, 0}};
      return r;
    }
    Matrix<ll> flip_x() {
      Matrix<ll> r = {{1, 0}, {0, -1}};
      return r;
    }
    Matrix<ll> flip_y() {
      Matrix<ll> r = {{-1, 0}, {0, 1}};
      return r;
    }
    Matrix<ll> flip_O() {
      Matrix<ll> r = {{-1, 0}, {0, -1}};
      return r;
    }
    Matrix<long double> flip_line(long double &theta) {
      theta *= 2;
      Matrix<long double> r = {{cos(theta), sin(theta)}, {sin(theta), -cos(theta)}};
      return r;
    }
    """

  'Matrix_affine':
    'prefix':'Matrix_affine'
    'body':"""
    template<typename T> Matrix<T> translation(const T &x, const T &y) {
      Matrix<T> r = {{1, 0, x}, {0, 1, y}, {0, 0, 1}};
      return r;
    }
    Matrix<long double> rotate(const long double &theta) {
      Matrix<long double> r = {{cos(theta), -sin(theta), 0}, {sin(theta), cos(theta), 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> rotate_left() {
      Matrix<ll> r = {{0, -1, 0}, {1, 0, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> rotate_right() {
      Matrix<ll> r = {{0, 1, 0}, {-1, 0, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_x() {
      Matrix<ll> r = {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_y() {
      Matrix<ll> r = {{-1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_O() {
      Matrix<ll> r = {{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}};
      return r;
    }
    """

  'matrix':
    'prefix':'matrix'
    'body':'Matrix<${1:mint}> $2;'

  'FormalPowerSeries':
    'prefix':'FPS'
    'body':"""
    template<typename T = mint> struct FPS : vector<T> {
      using vector<T>::vector;
      using vector<T>::operator=;
      FPS pre(ll deg) const { return FPS(begin(*this), begin(*this) + min((ll)this->size(), deg)); }
      FPS rev(ll deg = -1) const {
        FPS r(*this);
        if(deg != -1) {r.resize(deg, T(0));}
        reverse(r.begin(), r.end());
        return r;
      }
      void shrink() {
        while(this->size() && this->back() == T(0)) {this->pop_back();}
      }
      FPS operator+(const FPS &f) const { return FPS(*this) += f; }
      FPS operator+(const T &x) const { return FPS(*this) += x; }
      FPS operator-(const FPS &f) const { return FPS(*this) -= f; }
      FPS operator-(const T &x) const { return FPS(*this) -= x; }
      FPS operator*(const FPS &f) const { return FPS(*this) *= f; }
      FPS operator*(const T &x) const { return FPS(*this) *= x; }
      FPS operator/(const FPS &f) const { return FPS(*this) /= f; }
      FPS operator/(const T &x) const { return FPS(*this) /= x; }
      FPS operator%(const FPS &f) const { return FPS(*this) %= f; }
      FPS &operator+=(const FPS &f) {
        if(f.size() > this->size()) {this->resize(f.size());}
        for(ll i = 0; i < (ll)f.size(); i++) {(*this)[i] += f[i];}
        return *this;
      }
      FPS &operator-=(const FPS &f) {
        if(f.size() > this->size()) {this->resize(f.size());}
        for(ll i = 0; i < (ll)f.size(); i++) {(*this)[i] -= f[i];}
        return *this;
      }
      FPS &operator*=(const FPS &f) {
        if(T::mod() == 998244353) {*this = convolution(*this, f);}
        else {
          ll n = this->size(), m = f.size();
          vector<ll> a(n), b(m);
          static constexpr ll MOD1 = 754974721, MOD2 = 167772161, MOD3 = 469762049;
          static constexpr ll M1_M2 = internal::inv_gcd(MOD1, MOD2).second, M12_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second, M12 = (MOD1 * MOD2) % T::mod();
          for(ll i = 0; i < n; i++) {a[i] = (*this)[i].val();}
          for(ll i = 0; i < m; i++) {b[i] = f[i].val();}
          vector<ll> x = convolution<MOD1>(a, b), y = convolution<MOD2>(a, b), z = convolution<MOD3>(a, b);
          vector<T> c(n + m - 1);
          for(ll i = 0; i < n + m - 1; i++) {
            ll v1 = (y[i] - x[i]) * M1_M2 % MOD2;
            if(v1 < 0) {v1 += MOD2;}
            ll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_M3 % MOD3;
            if(v2 < 0) {v2 += MOD3;}
            c[i] = x[i] + MOD1 * v1 + M12 * v2;
          }
          *this = c;
        }
        return *this;
      }
      FPS &operator*=(vector<pair<ll, T>> &f) const {
        const ll n = (ll)this->size(), m = f.back().first;
        auto [d, c] = f.front();
        if(d == 0) {f.erase(f.begin());}
        else {c = 0;}
        for(ll i = n - 1; i >= 0; i--) {
          (*this)[i] *= c;
          for(auto &[j, b] : f) {
            if(j > i) {break;}
            (*this)[i] += (*this)[i - j] * b;
          }
        }
        return *this;
      }
      void mul(const ll d, const T c) {  // *(cx^d + 1)
        ll n = this->size();
        for(ll i = n - d - 1; i >= 0; i--) {(*this)[i + d] += (*this)[i] * c;}
      }
      FPS &operator/=(const FPS &f) {
        if(this->size() < f.size()) {
          this->clear();
          return *this;
        }
        ll n = this->size() - f.size() + 1;
        return *this = (rev().pre(n) * f.rev().inv(n)).pre(n).rev(n);
      }
      void div(const ll d, const T c) {  // /(cx^d + 1)
        ll n = this->size();
        for(ll i = 0; i < n - d; i++) {(*this)[i + d] -= (*this)[i] * c;}
      }
      FPS &operator%=(const FPS &f) { return *this -= *this / f * f; }
      pair<FPS, FPS> div_mod(const FPS &f) {
        FPS g = *this / f;
        return {g, *this - g * f};
      }
      FPS operator-() {
        FPS r(this->size());
        for(ll i = 0; i < (this->size()); i++) {r[i] = -(*this)[i];}
        return r;
      }
      FPS &operator+=(const T &x) {
        if(this->empty()) {this->resize(1);}
        (*this)[0] += x;
        return *this;
      }
      FPS &operator-=(const T &x) {
        if(this->empty()) {this->resize(1);}
        (*this)[0] -= x;
        return *this;
      }
      FPS &operator*=(const T &x) {
        for(ll i = 0; i < (ll)this->size(); i++) {(*this)[i] *= x;}
        return *this;
      }
      FPS &operator/=(const T &x) {
        for(ll i = 0; i < (ll)this->size(); i++) {(*this)[i] /= x;}
        return *this;
      }
      FPS operator>>(ll sz) {
        if((ll)this->size() <= sz) {return {};}
        FPS r(*this);
        r.erase(r.begin(), r.begin() + sz);
        return r;
      }
      FPS operator<<(ll sz) {
        FPS r(*this);
        r.insert(r.begin(), sz, T(0));
        return r;
      }
      FPS dot(const FPS &f) const {
        FPS r(min(this->size(), f.size()));
        for(ll i = 0; i < r.size(); i++) {r[i] = (*this)[i] * f[i];}
        return r;
      }
      T operator()(T x) const {
        T r = 0, w = 1;
        for(auto &i : (*this)) {
          r += w * i;
          w *= x;
        }
        return r;
      }
      FPS diff() const {
        const int n = (int)this->size();
        FPS r(n);
        for(ll i = 1; i < n; i++) {r[i - 1] = (*this)[i] * T(i);}
        r[n - 1] = 0;
        return r;
      }
      FPS integral() const {
        ll n = this->size(), mod = T::mod();
        vector<T> inv(n);
        inv[1] = 1;
        for(ll i = 2; i < n; i++) {inv[i] = -inv[mod % i] * (mod / i);}
        FPS r(n);
        for(ll i = n - 2; i >= 0; i--) {r[i + 1] = (*this)[i] * inv[i + 1];}
        r[0] = 0;
        return r;
      }
      FPS inv(ll deg = -1) const {
        ll n = this->size();
        if(deg == -1) {deg = n;}
        assert(n != 0 && (*this)[0] != T(0));
        FPS res{(*this)[0].inv()};
        if(T::mod() == 998244353) {
          while((ll)res.size() < deg) {
            ll d = res.size();
            FPS f(this->begin(), this->begin() + min(n, d * 2)), g(res);
            f.resize(d * 2);
            g.resize(d * 2);
            internal::butterfly(f);
            internal::butterfly(g);
            for(ll i = 0; i < d * 2; i++) {f[i] *= g[i];}
            internal::butterfly_inv(f);
            f.erase(f.begin(), f.begin() + d);
            f.resize(d * 2);
            internal::butterfly(f);
            for(ll i = 0; i < d * 2; i++) {f[i] *= g[i];}
            internal::butterfly_inv(f);
            T iz = T(d * 2).inv();
            iz *= -iz;
            for(ll i = 0; i < d; i++) {f[i] *= iz;}
            res.insert(res.end(), f.begin(), f.begin() + d);
          }
        }
        else {
          for(ll i = 1; i < deg; i <<= 1) {res = (res + res - res * res * pre(i << 1)).pre(i << 1);}
        }
        return res.pre(deg);
      }
      FPS log(ll deg = -1) const {
        assert((*this)[0] == T(1));
        if(deg == -1) {deg = this->size();}
        return (this->diff() * this->inv(deg)).pre(deg).integral();
      }
      FPS sqrt(
          ll deg = -1, const function<T(T)> &get_sqrt = [](T) { return T(1); }) const {
        const ll n = (ll)this->size();
        if(deg == -1) {deg = n;}
        if((*this)[0] == T(0)) {
          for(ll i = 1; i < n; i++) {
            if((*this)[0] != T(0)) {
              if(i & 1) {return {};}
              if(deg - i / 2 <= 0) {break;}
              auto r = (*this >> i).sqrt(deg - i / 2, get_sqrt);
              if(r.empty()) {return {};}
              r = r << (i / 2);
              if(r.size() < deg) {r.resize(deg, T(0));}
              return r;
            }
          }
          return FPS(deg, 0);
        }
        auto sq = T(get_sqrt((*this)[0]));
        if(sq * sq != (*this)[0]) {return {};}
        FPS r{sq};
        T inv2 = T(1) / T(2);
        for(ll i = 1; i < deg; i <<= 1) {r = (r + pre(i << 1) * r.inv(i << 1)) * inv2;}
        return r.pre(deg);
      }
      FPS sqrt(const function<T(T)> &get_sqrt, ll deg = -1) const { return sqrt(deg, get_sqrt); }
      FPS exp(ll deg = -1) const {
        ll n = this->size();
        assert((*this)[0] == T(0));
        if(deg == -1) {deg = n;}
        if(T::mod() == 998244353) {
          FPS inv;
          inv.reserve(deg);
          inv.emplace_back(T(0));
          inv.emplace_back(T(1));
          auto internal_integral = [&](FPS &f) {
            ll n = f.size(), mod = T::mod();
            while((ll)inv.size() <= n) {
              ll i = inv.size();
              inv.emplace_back((-inv[mod % i]) * (mod / i));
            }
            f.insert(f.begin(), T(0));
            for(ll i = 1; i <= n; i++) {f[i] *= inv[i];}
          };
          auto internal_diff = [](FPS &f) {
            if(f.empty()) {return;}
            f.erase(f.begin());
            T c = 1;
            for(ll i = 0; i < (ll)f.size(); i++, c++) {f[i] *= c;}
          };
          FPS b{1, 1 < (ll)this->size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};
          for(ll m = 2; m <= deg; m <<= 1) {
            auto y = b;
            y.resize(m * 2);
            internal::butterfly(y);
            z1 = z2;
            FPS z(m);
            for(ll i = 0; i < m; i++) {z[i] = y[i] * z1[i];}
            internal::butterfly_inv(z);
            T si = T(m).inv();
            for(ll i = 0; i < m; i++) {z[i] *= si;}
            fill(z.begin(), z.begin() + m / 2, T(0));
            internal::butterfly(z);
            for(ll i = 0; i < m; i++) {z[i] *= -z1[i];}
            internal::butterfly_inv(z);
            for(ll i = 0; i < m; i++) {z[i] *= si;}
            c.insert(c.end(), z.begin() + m / 2, z.end());
            z2 = c;
            z2.resize(m * 2);
            internal::butterfly(z2);
            FPS x(this->begin(), this->begin() + min((ll)this->size(), m));
            x.resize(m);
            internal_diff(x);
            x.emplace_back(T(0));
            internal::butterfly(x);
            for(ll i = 0; i < m; i++) {x[i] *= y[i];}
            internal::butterfly_inv(x);
            for(ll i = 0; i < m; i++) {x[i] *= si;}
            x -= b.diff();
            x.resize(m * 2);
            for(ll i = 0; i < m - 1; i++) {
              x[m + i] = x[i];
              x[i] = T(0);
            }
            internal::butterfly(x);
            for(ll i = 0; i < m * 2; i++) {x[i] *= z2[i];}
            internal::butterfly_inv(x);
            T si2 = T(m << 1).inv();
            for(ll i = 0; i < m * 2; i++) {x[i] *= si2;}
            x.pop_back();
            internal_integral(x);
            for(ll i = m; i < min((ll)this->size(), m * 2); i++) {x[i] += (*this)[i];}
            fill(x.begin(), x.begin() + m, T(0));
            internal::butterfly(x);
            for(ll i = 0; i < m * 2; i++) {x[i] *= y[i];}
            internal::butterfly_inv(x);
            for(ll i = 0; i < m * 2; i++) {x[i] *= si2;}
            b.insert(b.end(), x.begin() + m, x.end());
          }
          return b.pre(deg);
        }
        else {
          FPS r({T(1)});
          for(ll i = 1; i < deg; i <<= 1) {r = (r * (pre(i << 1) + T(1) - r.log(i << 1))).pre(i << 1);}
          return r.pre(deg);
        }
      }
      FPS pow(ll k) {
        ll n = (ll)this->size();
        assert(k >= 0);
        if(k == 0) {
          FPS r(n, T(0));
          r[0] = T(1);
          return r;
        }
        for(ll i = 0; i < n; i++) {
          if(i * k > n) {return FPS(n, T(0));}
          if((*this)[i] != T(0)) {
            T rev = (*this)[i].inv();
            FPS r = (((*this * rev) >> i).log() * k).exp() * ((*this)[i].pow(k));
            r = (r << (i * k)).pre(n);
            if((ll)r.size() < n) {r.resize(n, T(0));}
            return r;
          }
        }
        return *this;
      }
      FPS mod_pow(ll k, FPS f) const {
        FPS modinv = f.rev().inv();
        auto get_div = [&](FPS base) {
          if(base.size() < f.size()) {
            base.clear();
            return base;
          }
          ll n = base.size() - f.size() + 1;
          return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);
        };
        FPS x(*this), r{1};
        while(k > 0) {
          if(k & 1) {
            r *= x;
            r -= get_div(r) * f;
            r.shrink();
          }
          x *= x;
          x -= get_div(x) * f;
          x.shrink();
          k >>= 1;
        }
        return r;
      }
      FPS taylor_shift(T c) const {  // g(x) s.t. g(x)=f(x+c)
        ll n = (ll)this->size();
        vector<T> fact(n), rfact(n);
        fact[0] = rfact[0] = T(1);
        for(ll i = 1; i < n; i++) {fact[i] = fact[i - 1] * T(i);}
        rfact[n - 1] = T(1) / fact[n - 1];
        for(ll i = n - 1; i >= 2; i--) {rfact[i - 1] = rfact[i] * T(i);}
        FPS r(*this);
        for(ll i = 0; i < n; i++) {r[i] *= fact[i];}
        r = r.rev();
        FPS bs(n, T(1));
        for(ll i = 1; i < n; i++) {bs[i] = bs[i - 1] * c * rfact[i] * fact[i - 1];}
        r = (r * bs).pre(n);
        r = r.rev();
        for(ll i = 0; i < n; i++) {r[i] *= rfact[i];}
        return r;
      }
    };
    """

  'PrimeCount':
    'prefix':'PrimeCount'
    'body':"""
    uint64_t root(uint64_t a, int k) {
      if(a <= 1 || k == 1) { return a; }
      if(k >= 64) { return 1; }
      auto check = [&](__uint128_t n) {
        __uint128_t x = 1, m = n;
        for(ll p = k; p; p >>= 1, m *= m) {
          if(p & 1) { x *= m; }
        }
        return x <= a;
      };
      uint64_t n = powl(a, (long double)(1.0) / k);
      while(!check(n)) { --n; }
      while(check(n + 1)) { ++n; }
      return n;
    }

    vector<bool> Eratosthenes(int n) {
      vector<bool> prime(n + 1, true);
      if(n >= 0) { prime[0] = false; }
      if(n >= 1) { prime[1] = false; }
      for(int i = 2; i * i <= n; i++) {
        if(!prime[i]) { continue; }
        for(int j = i + i; j <= n; j += i) { prime[j] = false; }
      }
      return prime;
    }

    struct PrimeCount {
     private:
      ll p2(ll x, ll y) {
        if(x < 4) { return 0; }
        ll a = cnt(y), b = cnt(root(x, 2));
        if(a >= b) { return 0; }
        ll sum = (a - 2) * (a + 1) / 2 - (b - 2) * (b + 1) / 2;
        for(ll i = a; i < b; i++) { sum += cnt(x / primes[i]); }
        return sum;
      }
      ll phi(ll m, ll n) {
        if(m < 1) { return 0; }
        if(n > m) { return 1; }
        if(n < 1) { return m; }
        if(m <= primes[n - 1] * primes[n - 1]) { return cnt(m) - n + 1; }
        if(m <= primes[n - 1] * primes[n - 1] * primes[n - 1] && m <= sq) {
          ll sx = cnt(root(m, 2)), ans = cnt(m) - (sx + n - 2) * (sx - n + 1) / 2;
          for(ll i = n; i < sx; i++) { ans += cnt(m / primes[i]); }
          return ans;
        }
        return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);
      }

     public:
      ll sq;
      vector<bool> prime;
      vector<ll> prime_sum, primes;
      PrimeCount(ll n): sq(root(n, 2)), prime_sum(sq + 1) {
        prime = Eratosthenes(sq);
        for(int i = 1; i <= sq; i++) { prime_sum[i] = prime_sum[i - 1] + prime[i]; }
        primes.reserve(prime_sum[sq]);
        for(int i = 1; i <= sq; i++) {
          if(prime[i]) { primes.emplace_back(i); }
        }
      }
      ll cnt(ll n) {
        if(n <= sq) { return prime_sum[n]; }
        ll m = root(n, 3), a = cnt(m);
        return phi(n, a) + a - 1 - p2(n, m);
      }
      inline ll operator()(ll n) { return cnt(n); }
    } P(1e11);
    """

  'primecount':
    'prefix':'primecount'
    'body':'PrimeCount($1);'

  'mysort':
    'prefix':'mysort'
    'body':"""
    ranges::sort($1,[&](auto x,auto y){return $2;});$3 // condition to put x front
    """

  'sortidx':
    'prefix':'sortidx'
    'body':"""
    vector<ll> idx(n);
    iota(idx.begin(), idx.end(), 0);
    ranges::sort(idx, [&](auto i, auto j) { return $1[i] < $1[j]; });
    """

  'scc':
    'prefix':'scc'
    'body':'scc_graph g(n);'

  'suffix_array':
    'prefix':'suffix_array'
    'body':'auto sa=suffix_array($1);$2'

  'lcp_array':
    'prefix':'lcp_array'
    'body':'auto la=lcp_array($1,sa);$2'

  'z_algorithm':
    'prefix':'z_algorithm'
    'body':'auto z=z_algorithm($1);$2'

  'fenwick_tree':
    'prefix':'fenwick_tree'
    'body':"""
    fenwick_tree<ll> $1(n);
    // f.add(i,x) f[i]+=x;
    // f.sum(l,r) sum[l,r)
    """

  'string_repetition':
    'prefix':'string_repetition'
    'body':"""
    ll sz=$1.size(),l=sz;
    auto z = z_algorithm($1);
    for(ll i=1;i<sz;i++){
      if(z[i]==sz-i&&sz%i==0){
        l=i;
        break;
      }
    }
    """

  'testcase':
    'prefix':'testcase'
    'body':"""
    ll ${1:q}; cin>>${1:q};
    while(${1:q}--){
      $2
    }
    """

  'iota':
    'prefix':'iota'
    'body':'iota(${1:v}.begin(),${1:v}.end(),0);$2'

  'fixed':
    'prefix':'fixed'
    'body':'cout << fixed << setprecision(12);'

  'MaxFlow':
    'prefix':'maxflow'
    'body':'mf_graph<ll> g(n); ${1://https://atcoder.github.io/ac-library/document_ja/maxflow.html}'

  'add_edge':
    'prefix':'add_edge'
    'body':'add_edge($1);$2'

  'BipartiteMatching':
    'prefix':'BipartiteMatching'
    'body':"""
    ll BipartiteMatching(vector<vector<ll>>& g) {
      ll n = g.size();
      vector<ll> color(n, -1);
      function<bool(ll, ll)> DFS = [&](ll v, ll c) {
        color[v] = c;
        for(auto &nv : g[v]) {
          if(color[nv] != -1) {
            if(color[nv] == c) {return false;}
            continue;
          }
          if(!DFS(nv, 1 - c)) {return false;}
        }
        return true;
      };
      for(ll i = 0; i < n; i++) {
        if(color[i] == -1) {
          if(!DFS(i, 0)) {return -1;}
        }
      }
      mf_graph<ll> f(n + 2);
      for(ll i = 0; i < n; i++) {
        !color[i] ? f.add_edge(n, i, 1) : f.add_edge(i, n + 1, 1);
        for(auto &j : g[i]) {
          if(i >= j) {continue;}
          !color[i] ? f.add_edge(i, j, 1) : f.add_edge(j, i, 1);
        }
      }
      return f.flow(n, n + 1);
    }
    """

  'bipartitematching':
    'prefix':'bipartitematching'
    'body':'BipartiteMatching(g);'

  'Rational':
    'prefix':'Rational'
    'body':"""
    template<typename T> struct Rational {
      T num, den;
      Rational() {}
      Rational(T num_): num(num_), den(1) {}
      Rational(T num_, T den_): num(num_), den(den_) {
        if(den < 0) num = -num, den = -den;
      }
      static Rational make(const T& x, const T& y) {
        Rational m;
        return m.num = x, m.den = y, m;
      }
      friend ostream& operator<<(ostream& os, const Rational& r) {
        return (os << r.num << " / " << r.den);
      }
      Rational& operator=(T val) { return *this = Rational(val); }
      bool operator<(const Rational& val) const { return num * val.den < den * val.num; }
      bool operator<(const T val) const { return *this < Rational(val); }
      friend bool operator<(const T val1, const Rational& val2) { return Rational(val1) < val2; }
      bool operator>(const Rational& val) const { return val < *this; }
      bool operator>(const T val) const { return *this > Rational(val); }
      friend bool operator>(const T val1, const Rational& val2) { return Rational(val1) > val2; }
      bool operator<=(const Rational& val) const { return !(*this > val); }
      bool operator<=(const T val) const { return *this <= Rational(val); }
      friend bool operator<=(const T val1, const Rational& val2) { return Rational(val1) <= val2; }
      bool operator>=(const Rational& val) const { return !(*this < val); }
      bool operator>=(const T val) const { return *this >= Rational(val); }
      friend bool operator>=(const T val1, const Rational& val2) { return Rational(val1) >= val2; }
      bool operator==(const Rational& val) const { return num * val.den == den * val.num; }
      bool operator==(const T val) const { return *this == Rational(val); }
      friend bool operator==(const T val1, const Rational& val2) { return Rational(val1) == val2; }
      bool operator!=(const Rational& val) const { return !(*this == val); }
      bool operator!=(const T val) const { return *this != Rational(val); }
      friend bool operator!=(const T val1, const Rational& val2) { return Rational(val1) != val2; }
      explicit operator bool() const noexcept { return num; }
      bool operator!() const noexcept { return !static_cast<bool>(*this); }
      Rational operator+() const { return *this; }
      Rational operator-() const { return make(-num, den); }
      friend Rational abs(const Rational& val) { return make(abs(val.num), val.den); }
      Rational operator+(const Rational& val) const { return make(num * val.den + val.num * den, den * val.den); }
      Rational operator+(T val) const { return *this + Rational(val); }
      friend Rational operator+(T a, const Rational& b) { return b + a; }
      Rational& operator+=(const Rational& val) { return *this = *this + val; }
      Rational& operator+=(const T& val) { return *this = *this + val; }
      Rational& operator++() { return *this += 1; }
      Rational operator++(int) { return make(num + den, den); }
      Rational operator-(const Rational& val) const { return make(num * val.den - val.num * den, den * val.den); }
      Rational operator-(T val) const { return *this - Rational(val); }
      friend Rational operator-(T a, const Rational& b) { return Rational(a) - b; }
      Rational& operator-=(const Rational& val) { return *this = *this - val; }
      Rational& operator-=(const T& val) { return *this = *this - val; }
      Rational& operator--() { return *this -= 1; }
      Rational operator--(int) { return make(num - den, den); }
      Rational operator*(const Rational& val) const { return make(num * val.num, den * val.den); }
      Rational operator*(T val) const { return *this * Rational(val); }
      friend Rational operator*(T a, const Rational& b) { return b * a; }
      Rational& operator*=(const Rational& val) { return *this = *this * val; }
      Rational& operator*=(const T& val) { return *this = *this * val; }
      Rational operator/(const Rational& val) const { return make(num * val.den, den * val.num); }
      Rational operator/(T val) const { return *this / Rational(val); }
      friend Rational operator/(T a, const Rational& b) { return Rational(a) / b; }
      Rational& operator/=(const Rational& val) { return *this / val; }
      Rational& operator/=(const T& val) { return *this = *this / val; }
    };
    """

  'ConvexHullTrick':
    'prefix':'ConvexHullTrick'
    'body':"""
    template<typename T, bool isMin> struct ConvexHullTrick {
      deque<pair<T, T>> H;
      ConvexHullTrick() = default;
      bool empty() const { return H.empty(); }
      void clear() { H.clear(); }
      inline int sgn(T x) { return x == 0 ? 0 : (x < 0 ? -1 : 1); }
      inline bool check(const pair<T, T> &a, const pair<T, T> &b, const pair<T, T> &c) {
        if(b.second == a.second || c.second == b.second) {return sgn(b.first - a.first) * sgn(c.second - b.second) >= sgn(c.first - b.first) * sgn(b.second - a.second);}
        if(is_integral<T>::value) {return (b.second - a.second) / (a.first - b.first) >= (c.second - b.second) / (b.first - c.first);}
        else {return (b.first - a.first) * sgn(c.second - b.second) / abs(b.second - a.second) >= (c.first - b.first) * sgn(b.second - a.second) / abs(c.second - b.second);}
      }
      void add(T a, T b) {  // O(n) in total
        if(!isMin) {a *= -1, b *= -1;}
        pair<T, T> line(a, b);
        if(empty()) {
          H.emplace_front(line);
          return;
        }
        if(H.front().first <= a) {
          if(H.front().first == a) {
            if(H.front().second <= b) {return;}
            H.pop_front();
          }
          while(H.size() >= 2 && check(line, H.front(), H[1])) {H.pop_front();}
          H.emplace_front(line);
        }
        else {
          assert(a <= H.back().first);
          if(H.back().first == a) {
            if(H.back().second <= b) {return;}
            H.pop_back();
          }
          while(H.size() >= 2 && check(H[H.size() - 2], H.back(), line)) {H.pop_back();}
          H.emplace_back(line);
        }
      }
      inline T get_y(const pair<T, T> &a, const T &x) { return a.first * x + a.second; }
      T query(T x) {  // O(log n)
        assert(!empty());
        int l = -1, r = H.size() - 1;
        while(l + 1 < r) {
          int m = (l + r) >> 1;
          if(get_y(H[m], x) >= get_y(H[m + 1], x)) {l = m;}
          else {r = m;}
        }
        if(isMin) {return get_y(H[r], x);}
        return -get_y(H[r], x);
      }
      T query_inc(T x) {  // query の x が広義単調増加の場合，全体で O(n+q)
        assert(!empty());
        while(H.size() >= 2 && get_y(H.front(), x) >= get_y(H[1], x)) {H.pop_front();}
        if(isMin) {return get_y(H.front(), x);}
        return -get_y(H.front(), x);
      }
      T query_dec(T x) {  // query の x が広義単調減少の場合，全体で O(n+q)
        assert(!empty());
        while(H.size() >= 2 && get_y(H.back(), x) >= get_y(H[H.size() - 2], x)) {H.pop_back();}
        if(isMin) {return get_y(H.back(), x);}
        return -get_y(H.back(), x);
      }
    };
    template<typename T> using ConvexHullTrick_min = ConvexHullTrick<T, 1>;
    template<typename T> using ConvexHullTrick_max = ConvexHullTrick<T, 0>;
    """

  'ConvexHullTrick_min':
    'prefix':'ConvexHullTrick_min'
    'body':'ConvexHullTrick_min<ll> c;'

  'ConvexHullTrick_max':
    'prefix':'ConvexHullTrick_max'
    'body':'ConvexHullTrick_max<ll> c;'

  'Partition':
    'prefix':'Partition'
    'body':"""
    vector<vector<ll>> Partition;
    function<void(vector<ll>)> DFS = [&](vector<ll> v) {
      Partition.emplace_back(v);
      ll s = v.size();
      if(s == 1) {
        for(ll i = 1; i <= v[0] / 2; i++) {
          vector<ll> nv = {i, v[0] - i};
          DFS(nv);
        }
      }
      else {
        for(ll i = v[s - 2]; i <= v[s - 1] / 2; i++) {
          vector<ll> nv = v;
          nv.pop_back();
          nv.emplace_back(i);
          nv.emplace_back(v[s - 1] - i);
          DFS(nv);
        }
      }
    };
    DFS({n});
    """

  'partition':
    'prefix':'partition'
    'body':'Partition'

  'teleporter':
    'prefix':'teleporter'
    'body':"""
    ll path_len;
    vector<ll> path, loop;

    void order_ini(vector<ll> &nx, ll s = 0) {
      vector<ll> visited(nx.size(), -1);
      for(ll i = 0, p = s;; i++, p = nx[p]) {
        if(visited[p] != -1) {
          path_len = visited[p];
          break;
        }
        loop.emplace_back(p);
        visited[p] = i;
      }
      for(ll i = 0; i < path_len; i++) {path.emplace_back(loop[i]);}
      loop.erase(loop.begin(), loop.begin() + path_len);
    }

    ll pos(ll k) {
      return k < path_len ? path[k] : loop[(k - path_len) % loop.size()];
    }
    """

  'LiChaoTree':
    'prefix':'LiChaoTree'
    'body':"""
    template<typename T, T x_low, T x_high, T id> struct DynamicLiChaoTree {
      struct Line {
        T a, b;
        Line(T a, T b): a(a), b(b) {}
        inline T get(T x) const { return a * x + b; }
      };
      struct Node {
        Line x;
        Node *l, *r;
        Node(const Line &x): x{x}, l{nullptr}, r{nullptr} {}
      };
      Node *root;
      DynamicLiChaoTree(): root{nullptr} {}
      Node *add_line(Node *t, Line &x, const T &l, const T &r, const T &x_l, const T &x_r) {
        if(!t) return new Node(x);
        T t_l = t->x.get(l), t_r = t->x.get(r);
        if(t_l <= x_l && t_r <= x_r) {return t;}
        else if(t_l >= x_l && t_r >= x_r) {
          t->x = x;
          return t;
        }
        else {
          T m = (l + r) / 2;
          if(m == r) {--m;}
          T t_m = t->x.get(m), x_m = x.get(m);
          if(t_m > x_m) {
            swap(t->x, x);
            if(x_l >= t_l) {t->l = add_line(t->l, x, l, m, t_l, t_m);}
            else {t->r = add_line(t->r, x, m + 1, r, t_m + x.a, t_r);}
          }
          else {
            if(t_l >= x_l) {t->l = add_line(t->l, x, l, m, x_l, x_m);}
            else {t->r = add_line(t->r, x, m + 1, r, x_m + x.a, x_r);}
          }
          return t;
        }
      }
      void add_line(const T &a, const T &b) {
        Line x(a, b);
        root = add_line(root, x, x_low, x_high, x.get(x_low), x.get(x_high));
      }
      Node *add_segment(Node *t, Line &x, const T &a, const T &b, const T &l, const T &r, const T &x_l, const T &x_r) {
        if(r < a || b < l) {return t;}
        if(a <= l && r <= b) {
          Line y{x};
          return add_line(t, y, l, r, x_l, x_r);
        }
        if(t) {
          T t_l = t->x.get(l), t_r = t->x.get(r);
          if(t_l <= x_l && t_r <= x_r) {return t;}
        }
        else {t = new Node(Line(0, id));}
        T m = (l + r) / 2;
        if(m == r) {--m;}
        T x_m = x.get(m);
        t->l = add_segment(t->l, x, a, b, l, m, x_l, x_m);
        t->r = add_segment(t->r, x, a, b, m + 1, r, x_m + x.a, x_r);
        return t;
      }
      void add_segment(const T &l, const T &r, const T &a, const T &b) {
        Line x(a, b);
        root = add_segment(root, x, l, r - 1, x_low, x_high, x.get(x_low), x.get(x_high));
      }
      T query(const Node *t, const T &l, const T &r, const T &x) const {
        if(!t) {return id;}
        if(l == r) {return t->x.get(x);}
        T m = (l + r) / 2;
        if(m == r) {--m;}
        if(x <= m) {return min(t->x.get(x), query(t->l, l, m, x));}
        else {return min(t->x.get(x), query(t->r, m + 1, r, x));}
      }
      T query(const T &x) const {
        return query(root, x_low, x_high, x);
      }
    };
    // https://ei1333.github.io/library/structure/convex-hull-trick/dynamic-li-chao-tree.hpp
    """

  'modpow':
    'prefix':'modpow'
    'body':"""
    mint modpow(mint x, auto n) {
      mint r = 1;
      while(n) {
        if(n & 1) {r = r * x;}
        x = x * x;
        n >>= 1;
      }
      return r;
    }
    """

  'Rerooting':
    'prefix':'Rerooting'
    'body':"""
    template<typename Cost> struct Edge {
      int src, to;
      Cost cost;
      Edge(int s, int t, Cost c = 1): src(s), to(t), cost(c) {}
      operator int() const { return to; }
    };

    template<typename Cost> struct Graph : vector<vector<Edge<Cost>>> {
      Graph(int n): vector<vector<Edge<Cost>>>(n) {}
      void add_edge(int s, int t, Cost c = 1) { (*this)[s].emplace_back(s, t, c); }
    };

    template<typename Cost, typename Data, Data (*merge)(Data, Data), Data (*e)(), Data (*leaf)(), Data (*apply)(Data, int, int, Cost)>
    struct Rerooting : Graph<Cost> {
      vector<Data> dp, memo;
      Rerooting(int n): Graph<Cost>::Graph(n) {}
      vector<Data> build() {
        memo.resize(this->size(), e());
        dp.resize(this->size());
        dfs1(0, -1);
        dfs2(0, -1, e());
        return dp;
      }
      void dfs1(int c, int p) {
        bool upd = false;
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) {continue;}
          dfs1(d, c);
          upd = true;
          memo[c] = merge(memo[c], apply(memo[d], d, c, d.cost));
        }
        if(!upd) { memo[c] = leaf(); }
      }
      void dfs2(int c, int p, const Data &val) {
        vector<Data> ds{val};
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) { continue; }
          ds.push_back(apply(memo[d], d, c, d.cost));
        }
        int n = ds.size(), idx = 1;
        vector<Data> head(n + 1, e()), tail(n + 1, e());
        for(int i = 0; i++ < n;) { head[i] = merge(head[i - 1], ds[i - 1]); }
        for(int i = n; i-- > 0;) { tail[i] = merge(tail[i + 1], ds[i]); }
        dp[c] = head[n];
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) { continue; }
          Data sub = merge(head[idx], tail[idx + 1]);
          dfs2(d, c, apply(sub, c, d, d.cost));
          idx++;
        }
      }
    };

    using Data = ll;
    using Cost = ll;
    Data merge(Data a, Data b) { return ; }
    Data e() { return ; }
    Data leaf() { return ; }
    Data apply(Data a, int c, int, Cost w) { return ; }
    """

  'rerooting':
    'prefix':'rerooting'
    'body':'Rerooting<Cost, Data, merge, e, leaf, apply> g(n);'

  'lim_grid':
    'prefix':'lim_grid'
    'body':'if(nx<0||nx>=h||ny<0||ny>=w) {continue;}'

  'Maximum_rectangle_LR':
    'prefix':'Maximum_rectangle_LR'
    'body':"""
    pair<vector<ll>, vector<ll>> LR(vector<ll> &h) {
      ll n = h.size();
      vector<ll> l(n, 0), r(n, n - 1);
      stack<pair<ll, ll>> sl, sr;
      for(ll i = 0; i < n; i++) {
        while(!sl.empty() && h[i] <= sl.top().first) {sl.pop();}
        if(!sl.empty()) {l[i] = sl.top().second + 1;}
        sl.emplace(h[i], i);
      }
      for(ll i = n - 1; i >= 0; i--) {
        while(!sr.empty() && h[i] <= sr.top().first) {sr.pop();}
        if(!sr.empty()) {r[i] = sr.top().second - 1;}
        sr.emplace(h[i], i);
      }
      return {l, r};
    }
    // min l[i], max r[i] s.t. [l[i],r[i]]<=H[i], 0-indexed
    """

  'floor_ceil':
    'prefix':'Floor_Ceil'
    'body':"""
    auto floor(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b - (a % b < 0);
    }

    auto under(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b - (a % b <= 0);
    }

    auto ceil(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b + (a % b > 0);
    }

    auto over(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b + (a % b >= 0);
    }
    """

  'floor':
    'prefix':'floor'
    'body':'floor($1,$2)'

  'under':
    'prefix':'under'
    'body':'under($1,$2)'

  'ceil':
    'prefix':'ceil'
    'body':'ceil($1,$2)'

  'over':
    'prefix':'over'
    'body':'over($1,$2)'

  'RelaxedConvolution':
    'prefix':'RelaxedConvolution'
    'body':"""
    struct RelaxedConvolution {
      vector<mint> a, b, c;
      ll k;
      RelaxedConvolution(ll n): a(n), b(n), c(n), k(0) {}
      mint operator()(mint na, mint nb) {
        a[k] = na;
        b[k] = nb;
        ll s = k + 2;
        for(ll w = 1; s % w == 0 && w < s; w <<= 1) {
          for(ll r = 0; r < 2; r++) {
            if(r == 0 || w * 2 != s) {
              vector<mint> f(w), g(w);
              for(ll i = 0; i < w; i++) {f[i] = a[w - 1 + i], g[i] = b[k - w + 1 + i];}
              f = convolution(f, g);
              for(ll i = 0, j = k; i < (ll)f.size() && j < (ll)c.size(); i++, j++) {c[j] += f[i];}
            }
            swap(a, b);
          }
        }
        return c[k++];
      }
    };
    """

  'BinaryTrie':
    'prefix':'BinaryTrie'
    'body':"""
    template<int MAX_LOG = 32, typename T = int> struct BinaryTrie {
     private:
      struct node {
        int cnt;
        T lazy;
        node *ch[2];
        node(): cnt(0), lazy(0), ch{nullptr, nullptr} {}
      };
      void push(node *t, int b) {
        if((t->lazy >> (T)b) & (T)1) { swap(t->ch[0], t->ch[1]); }
        if(t->ch[0]) { t->ch[0]->lazy ^= t->lazy; }
        if(t->ch[1]) { t->ch[1]->lazy ^= t->lazy; }
        t->lazy = 0;
      }
      node *add(node *t, T val, int b = MAX_LOG - 1) {
        if(!t) { t = new node; }
        t->cnt += 1;
        if(b < 0) { return t; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        t->ch[f] = add(t->ch[f], val, b - 1);
        return t;
      }
      node *sub(node *t, T val, int b = MAX_LOG - 1) {
        assert(t);
        t->cnt -= 1;
        if(t->cnt == 0) { return nullptr; }
        if(b < 0) { return t; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        t->ch[f] = sub(t->ch[f], val, b - 1);
        return t;
      }
      T get_min(node *t, T val, int b = MAX_LOG - 1) {
        assert(t);
        if(b < 0) { return 0; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        f ^= !t->ch[f];
        return get_min(t->ch[f], val, b - 1) | ((T)f << (T)b);
      }
      T get(node *t, int k, int b = MAX_LOG - 1) {
        if(b < 0) { return 0; }
        push(t, b);
        int m = t->ch[0] ? t->ch[0]->cnt : 0;
        return k < m ? get(t->ch[0], k, b - 1) : get(t->ch[1], k - m, b - 1) | ((T)1 << (T)b);
      }
      int count_lower(node *t, T val, int b = MAX_LOG - 1) {
        if(!t || b < 0) { return 0; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        return (f && t->ch[0] ? t->ch[0]->cnt : 0) + count_lower(t->ch[f], val, b - 1);
      }
      node *root;

     public:
      BinaryTrie(): root(nullptr) {}
      int size() const { return root ? root->cnt : 0; }
      bool empty() const { return !root; }
      void insert(T val) { root = add(root, val); }
      void erase(T val) {
        if(!count(val)) { return; }
        root = sub(root, val);
      }
      void xor_all(T val) {
        if(root) { root->lazy ^= val; }
      }
      T max_element(T xor_val = 0) {
        xor_all(xor_val);
        T r = get_min(root, -1);
        xor_all(xor_val);
        return r;
      }
      T min_element(T xor_val = 0) {
        xor_all(xor_val);
        T r = get_min(root, 0);
        xor_all(xor_val);
        return r;
      }
      int lower_bound(T val, T xor_val = 0) {
        xor_all(xor_val);
        int r = count_lower(root, val);
        xor_all(xor_val);
        return r;
      }
      int upper_bound(T val, T xor_val = 0) {
        xor_all(xor_val);
        int r = count_lower(root, val + 1);
        xor_all(xor_val);
        return r;
      }
      T kth_smallest(int k, T xor_val = 0) {
        assert(0 <= k && k < size());
        xor_all(xor_val);
        T r = get(root, k);
        xor_all(xor_val);
        return r;
      }
      int count(T val) {
        if(!root) { return 0; }
        node *t = root;
        for(int i = MAX_LOG - 1; i >= 0; i--) {
          push(t, i);
          t = t->ch[(val >> (T)i) & (T)1];
          if(!t) { return 0; }
        }
        return t->cnt;
      }
    };
    """

  'binarytrie':
    'prefix':'binarytrie'
    'body':'BinaryTrie<30> b;'

  'ranges':
    'prefix':'ranges'
    'body':'ranges::'

  'views':
    'prefix':'views'
    'body':'views::'

  'views_reverse':
    'prefix':'views_reverse'
    'body':'views::reverse($1)$2'

  'views_keys':
    'prefix':'keys'
    'body':'views::keys($1)$2'

  'views_values':
    'prefix':'values'
    'body':'views::values($1)$2'

  'Lowlink':
    'prefix':'Lowlink'
    'body':"""
    struct Lowlink {
      const vector<vector<ll>> g;
      ll N;
      vector<ll> ord, low;
      vector<ll> articulation;  // 関節点
      vector<pair<ll, ll>> bridge;  // 橋 (辺(u, v)が u < v となるよう格納)
      Lowlink(const vector<vector<ll>> &g_): g(g_), N(g.size()), ord(N, -1), low(N, -1) {
        for(ll i = 0, k = 0; i < N; i++) {
          if(ord[i] == -1) {k = dfs(i, k, -1);}
        }
      }
      ll dfs(ll idx, ll k, ll par) {
        low[idx] = (ord[idx] = k++);
        ll cnt = 0;
        bool arti = false, second = false;
        for(auto &to : g[idx]) {
          if(ord[to] == -1) {
            cnt++;
            k = dfs(to, k, idx);
            low[idx] = min(low[idx], low[to]);
            arti |= (par != -1) && (low[to] >= ord[idx]);
            if(ord[idx] < low[to]) {bridge.emplace_back(minmax(idx, to));}
          }
          else if(to != par || second) {low[idx] = min(low[idx], ord[to]);}
          else {second = true;}
        }
        arti |= par == -1 && cnt > 1;
        if(arti) {articulation.emplace_back(idx);}
        return k;
      }
    };
    """

  'StringSearch':
    'prefix':'StringSearch'
    'body':"""
    template<typename T> struct SparseTable {
      inline static constexpr T INF = numeric_limits<T>::max() / 2;
      int N;
      vector<vector<T>> table;
      T f(T a, T b) { return min(a, b); }
      SparseTable() {}
      SparseTable(const vector<T> &v): N(ssize(v)) {
        int b = 1;
        while((1 << b) <= N) { ++b; }
        table.emplace_back(v);
        for(int i = 1; i < b; i++) {
          table.emplace_back(vector<T>(N, INF));
          for(int j = 0; j + (1 << i) <= N; j++) {
            table[i][j] = f(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);
          }
        }
      }
      T query(int l, int r) {  // [l, r)
        assert(0 <= l && l <= r && r <= N);
        if(l == r) { return INF; }
        int b = 31 - __builtin_clz(r - l);
        return f(table[b][l], table[b][r - (1 << b)]);
      }
    };

    template<typename T> struct StringSearch {
      const T &S;
      ll N;
      vector<int> sa, la, inv;
      SparseTable<int> sparse;
      StringSearch(const T &s_): S(s_), N(ssize(S)) {
        sa = suffix_array(S);
        la = lcp_array(S, sa);
        inv.resize(N);
        for(ll i = 0; i < N; i++) { inv[sa[i]] = i; }
        sparse = SparseTable<int>{la};
      }
      // lcp(s[i, N), s[j, N))
      ll lcp(ll i, ll j) {
        assert(0 <= min(i, j) && max(i, j) < N);
        if(i == j) { return N - i; }
        auto [x, y] = minmax(inv[i], inv[j]);
        return sparse.query(x, y);
      }
      // lcp(s[a, b), s[c, d))
      ll lcp(ll a, ll b, ll c, ll d) {
        assert(0 <= a && a <= b && b <= N);
        assert(0 <= c && c <= d && d <= N);
        ll l = lcp(a, c);
        return min({l, b - a, d - c});
      }
      ll lcp(pair<ll, ll> p, pair<ll, ll> q) {
        return lcp(p.first, p.second, q.first, q.second);
      }
      // s[i, N) > s[j, N) : 1
      // s[i, N) = s[j, N) : 0
      // s[i, N) < s[j, N) : -1
      ll compare(ll i, ll j) {
        assert(0 <= min(i, j) && max(i, j) < N);
        if(i == j) { return 0; }
        return inv[i] < inv[j] ? -1 : 1;
      }
      // s[a, b) > s[c, d) : 1
      // s[a, b) = s[c, d) : 0
      // s[a, b) < s[c, d) : -1
      ll compare(ll a, ll b, ll c, ll d) {
        ll l = lcp(a, b, c, d);
        return a + l == b     ? (c + l == d ? 0 : -1)
        : c + l == d          ? 1
        : S[a + l] < S[c + l] ? -1
                              : 1;
      }
      ll compare(pair<ll, ll> p, pair<ll, ll> q) {
        return compare(p.first, p.second, q.first, q.second);
      }
    };
    """

  'Tree':
    'prefix':'Tree'
    'body':"""
    struct Tree : vector<vector<ll>> {
     private:
      void dfs_sz(ll v, ll p) {
        sz[v] = 1;
        ord.emplace_back(v);
        for(ll i = p, x = 0; i != -1;) {
          bl[v][x] = i;
          i = bl[i][x], x++;
        }
        for(auto &nv : (*this)[v]) {
          if(nv == p) {
            if((ll)(*this)[v].size() >= 2 && nv == (*this)[v][0]) { std::swap((*this)[v][0], (*this)[v][1]); }
            else { continue; }
          }
          dp[nv] = dp[v] + 1;
          dfs_sz(nv, v);
          sz[v] += sz[nv];
          if(sz[nv] > sz[(*this)[v][0]]) { std::swap(nv, (*this)[v][0]); }
        }
      }
      void dfs_hld(ll v) {
        down[v] = id++;
        for(auto &nv : (*this)[v]) {
          if(nv == par(v)) { continue; }
          nx[nv] = (nv == (*this)[v][0] ? nx[v] : nv);
          dfs_hld(nv);
        }
        up[v] = id;
      }
      vector<pair<ll, ll>> ascend(ll u, ll v) const {
        vector<pair<ll, ll>> r;
        while(nx[u] != nx[v]) {
          r.emplace_back(down[u], down[nx[u]]);
          u = par(nx[u]);
        }
        if(u != v) { r.emplace_back(down[u], down[v] + 1); }
        return r;
      }
      vector<pair<ll, ll>> descend(ll u, ll v) const {
        if(u == v) { return {}; }
        if(nx[u] == nx[v]) { return {{down[u] + 1, down[v]}}; }
        auto r = descend(u, par(nx[v]));
        r.emplace_back(down[nx[v]], down[v]);
        return r;
      }

     public:
      ll n, root, id = 0;
      vector<array<ll, 24>> bl;
      vector<ll> dp, sz, ord, down, up, nx;
      Tree(ll n_, ll r = 0): n(n_), root(r) { this->resize(n); }
      Tree(vector<vector<ll>> &g, ll r = 0): n(g.size()), root(r) {
        *this = g;
        build();
      }
      void add_edge(ll u, ll v) {
        (*this)[u].emplace_back(v);
        (*this)[v].emplace_back(u);
      }
      void build() {
        bl.resize(n);
        dp.resize(n);
        sz.resize(n);
        down.assign(n, -1);
        up.assign(n, -1);
        nx.assign(n, root);
        for(auto &v : bl) { ranges::fill(v, -1); }
        dfs_sz(root, -1);
        dfs_hld(root);
      }
      ll depth(ll i) const { return dp[i]; }
      ll par(ll i) const { return i == root ? root : bl[i][0]; }
      ll order(ll i) const { return ord[i]; }
      ll in(ll i) const { return down[i]; }
      ll out(ll i) const { return up[i]; }
      ll size(ll i) const { return sz[i]; }
      ll kth_ancestor(ll i, ll k) const {
        if(dp[i] < k) { return -1; }
        while(k) {
          ll t = __builtin_ctz(k);
          i = bl[i][t], k ^= 1 << t;
        }
        return i;
      }
      ll dis(ll u, ll v) { return dp[u] + dp[v] - dp[lca(u, v)] * 2; }
      bool onpath(ll u, ll v, ll x) { return dis(u, v) == dis(u, x) + dis(x, v); }
      // vertex adjacent to u on u-v path
      ll nxt(ll u, ll v) const {
        if(dp[u] >= dp[v]) { return par(u); }
        ll x = kth_ancestor(v, dp[v] - dp[u] - 1);
        return bl[x][0] == u ? x : bl[u][0];
      }
      vector<ll> path(ll u, ll v) const {
        vector<ll> pre, suf;
        while(dp[u] > dp[v]) {
          pre.emplace_back(u);
          u = bl[u][0];
        }
        while(dp[u] < dp[v]) {
          suf.emplace_back(v);
          v = bl[v][0];
        }
        while(u != v) {
          pre.emplace_back(u);
          suf.emplace_back(v);
          u = bl[u][0];
          v = bl[v][0];
        }
        pre.emplace_back(u);
        ranges::reverse(suf);
        copy(suf.begin(), suf.end(), back_inserter(pre));
        return pre;
      }
      ll lca(ll u, ll v) {
        while(nx[u] != nx[v]) {
          if(down[u] < down[v]) { std::swap(u, v); }
          u = par(nx[u]);
        }
        return dp[u] < dp[v] ? u : v;
      }
      // vertex at distance x from u on u-v path
      ll jump(ll u, ll v, ll x) {
        ll lc = lca(u, v), d1 = dp[u] - dp[lc];
        if(x <= d1) { return kth_ancestor(u, x); }
        ll d = d1 + dp[v] - dp[lc];
        if(x <= d) { return kth_ancestor(v, d - x); }
        return -1;
      }
      vector<ll> diameter() {
        ll s = ranges::max_element(dp) - dp.begin();
        vector<ll> d(n, -1);
        d[s] = 0;
        queue<ll> q;
        q.emplace(s);
        while(!q.empty()) {
          ll v = q.front();
          q.pop();
          for(auto &nv : (*this)[v]) {
            if(d[nv] == -1) {
              d[nv] = d[v] + 1;
              q.emplace(nv);
            }
          }
        }
        ll t = ranges::max_element(d) - d.begin();
        return path(t, s);
      }
      template<typename F> void query(ll u, ll v, bool vertex, const F &f) {
        ll l = lca(u, v);
        for(auto &&[a, b] : ascend(u, l)) {
          ll s = a + 1, t = b;
          s > t ? f(t, s) : f(s, t);
        }
        if(vertex) f(down[l], down[l] + 1);
        for(auto &&[a, b] : descend(l, v)) {
          ll s = a, t = b + 1;
          s > t ? f(t, s) : f(s, t);
        }
      }
      template<typename F> void noncommutative_query(ll u, ll v, bool vertex, const F &f) {
        ll l = lca(u, v);
        for(auto &&[a, b] : ascend(u, l)) { f(a + 1, b); }
        if(vertex) { f(down[l], down[l] + 1); }
        for(auto &&[a, b] : descend(l, v)) { f(a, b + 1); }
      }
      template<typename F> void subtree_query(ll u, bool vertex, const F &f) {
        f(down[u] + int(!vertex), up[u]);
      }
    };
    """

  'PI':
    'prefix':'PI'
    'body':'numbers::pi'

  '__int128_t':
    'prefix':'int128t'
    'body':'__int128_t'

  'UniteInterval':
    'prefix':'UniteInterval'
    'body':"""
    // union of [a1,b1), [a2,b2) ...
    template<typename T> vector<pair<T,T>> UniteInterval(const vector<pair<T, T>> &v) {
      vector<pair<T, T>> u{v}, r;
      ranges::sort(u);
      for(auto &p : u) {
        r.emplace_back(p);
        while((ll)r.size() >= 2) {
          ll n = r.size();
          if(r[n - 2].second < r[n - 1].first) {break;}
          pair<T, T> q;
          q.first = r[n - 2].first;
          q.second = max<T>(r[n - 2].second, r[n - 1].second);
          r.pop_back();
          r.pop_back();
          r.emplace_back(q);
        }
      }
      return r;
    }
    """

  'uniteinterval':
    'prefix':'uniteinterval'
    'body':'auto u=UniteInterval($1);$2'

  'Mulall':
    'prefix':'Mulall'
    'body':"""
    auto mulall(vector<auto> &v) {
      ll n = ssize(v);
      queue<ll> q;
      for(ll i = 0; i < n; i++) {q.emplace(i);}
      while(ssize(q) >= 2) {
        ll x = q.front();
        q.pop();
        ll y = q.front();
        q.pop();
        v[x] = convolution(v[x], v[y]);
        q.emplace(x);
      }
      return v[q.front()];
    }
    """

  'mulall':
    'prefix':'mulall'
    'body':'mulall($1);$2'

  'Bostan_Mori':
    'prefix':'Bostan_Mori'
    'body':"""
    template<typename T> T Bostan_Mori(FPS<T> p, FPS<T> q, ll n) {
      ll m = max(p.size(), q.size());
      p.resize(m);
      q.resize(m);
      while(n) {
        FPS<T> r = q;
        for(ll i = 0; i < ssize(r); i += 2) {r[i] = -r[i];}
        FPS<T> v = q * r, u = p * r;
        for(ll i = n % 2; i < ssize(u); i += 2) {p[i / 2] = u[i];}
        for(ll i = 0; i < ssize(v); i += 2){ q[i / 2] = v[i];}
        n /= 2;
      }
      return p[0] / q[0];
    }

    // ini = { a_0, a_1, ..., a_{k-1} }
    // a_n = rec_0 * a_{n-1} + rec_1 * a_{n-2} +...+ rec_{k-1} * a_{n-k}
    template<typename T> T Recurrence(vector<T> &ini, vector<T> &rec, ll n) {
      ll s = ini.size(), k = rec.size();
      assert(s >= k);
      FPS<T> p, q(k + 1), a(s);
      q[0] = 1;
      for(ll i = 0; i < k; i++) {q[i + 1] = -rec[i];}
      for(ll i = 0; i < s; i++) {a[i] = ini[i];}
      p = (q * a).pre(k);
      return Bostan_Mori(p, q, n);
    }
    """

  'if':
    'prefix':'if'
    'body':'if($1){$2}$3'

  'elif':
    'prefix':'else if'
    'body':'else if($1){$2}$3'

  'else':
    'prefix':'else'
    'body':'else{$1}$2'

  'PersistentArray':
    'prefix':'PersistentArray'
    'body':"""
    template<typename T, int shift = 4> struct PersistentArray {
      struct Node {
        Node *ns[1 << shift];
        Node() { memset(ns, 0, sizeof(ns)); }
        Node(const Node &other) { memcpy(ns, other.ns, sizeof(ns)); }
        Node(const Node *other) { memcpy(ns, other->ns, sizeof(ns)); }
      };
      inline Node *my_new() { return new Node(); }
      inline Node *my_new(const Node &other) { return new Node(other); }
      inline Node *my_new(const Node *other) { return new Node(other); }
      inline T *my_new_leaf(const T &val) { return new T{val}; }
      static constexpr int mask = (1 << shift) - 1;
      Node *root;
      int depth;
      T ID;
      PersistentArray() {}
      PersistentArray(ll MAX, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {
        while(MAX) {
          depth++;
          MAX >>= shift;
        }
      }
      PersistentArray(const vector<T> &v, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {
        ll MAX = v.size();
        while(MAX) {
          depth++;
          MAX >>= shift;
        }
        for(ll i = 0; i < (ll)v.size(); i++) {
          Node *n = root;
          for(ll k = i, d = depth; d; d--) {
            if(!(n->ns[k & mask])) {
              if(d == 1) { n->ns[k & mask] = reinterpret_cast<Node *>(my_new_leaf(v[i])); }
              else { n->ns[k & mask] = my_new(); }
            }
            n = n->ns[k & mask];
            k >>= shift;
          }
        }
      }
      T get(Node *n, ll k) const {
        for(ll i = depth; i; i--) {
          n = n ? n->ns[k & mask] : nullptr;
          k >>= shift;
        }
        return n ? *reinterpret_cast<T *>(n) : ID;
      }
      T get(ll k) const { return get(root, k); }
      Node *update(Node *n, ll k, const T &val) {
        stack<pair<Node *, int>> st;
        for(ll i = depth; i; i--) {
          st.emplace(n, k & mask);
          n = n ? n->ns[k & mask] : nullptr;
          k >>= shift;
        }
        Node *chd = reinterpret_cast<Node *>(my_new_leaf(val));
        while(!st.empty()) {
          Node *par;
          ll k;
          tie(par, k) = st.top();
          st.pop();
          Node *nxt = par ? my_new(par) : my_new();
          nxt->ns[k] = chd;
          chd = nxt;
        }
        return root = chd;
      }
      Node *update(ll k, const T &val) { return update(root, k, val); }
    };
    """

  'lll':
    'prefix':'lll'
    'body':"""
    const ll D_SI = 125;
    struct lll : vector<ll> {
      static const ll BASE = 100000000;
      static const ll BASE_D = 8;
      ll sign;
      lll(ll n = 0): vector<ll>(D_SI, 0), sign(1) {
        if(n < 0) { sign = -1, n = -n; }
        (*this)[0] = n;
        this->normalize();
      }
      lll(ll size, ll n): vector<ll>(size, n), sign(1) {}
      lll &normalize() {
        ll c = 0;
        bool e = false;
        for(ll i = 0;; ++i) {
          if(i >= this->size()) { this->push_back(0); }
          if((*this)[i] < 0 && i + 1 >= this->size()) { this->push_back(0); }
          while((*this)[i] < 0) {
            (*this)[i + 1] -= 1;
            (*this)[i] += BASE;
          }
          ll a = (*this)[i] + c;
          (*this)[i] = a % BASE;
          if((*this)[i]) { e = 1; }
          c = a / BASE;
          if(c == 0 && i == this->size() - 1) { break; }
        }
        if(!e) { sign = 1; }
        return (*this);
      }
      friend lll abs(const lll &x) {
        lll z = x;
        if(z.sign == -1) { z.sign = 1; }
        return z;
      }
      lll operator-() const {
        lll r = *this;
        bool z = 1;
        for(ll i = 0; i < (ll)this->size(); i++) {
          if(r[i] != 0) {
            z = 0;
            break;
          }
        }
        if(!z) { r.sign = -r.sign; }
        return r;
      }
      lll &operator+=(const lll &r) {
        while(size() < r.size()) this->emplace_back(0);
        if(sign == r.sign) {
          for(ll i = 0; i < (ll)r.size(); i++) {
            (*this)[i] += r[i];
          }
        }
        else {
          if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }
          else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }
          if(abs(*this) >= abs(r)) {
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }
          }
          else {
            for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
          }
        }
        return this->normalize();
      }
      lll &operator-=(const lll &r) {
        while(size() < r.size()) { this->emplace_back(0); }
        if(sign == -r.sign) {
          for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
        }
        else {
          if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }
          else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }
          if(abs(*this) >= abs(r)) {
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }
          }
          else {
            for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
          }
        }
        return this->normalize();
      }
      lll &operator*=(ll r) {
        if((sign == 1 && r >= 0) || (sign == -1 && r < 0)) { sign = 1; }
        else { sign = -1; }
        if(r < 0) { r = -r; }
        for(ll i = 0; i < (ll)size(); i++) { (*this)[i] *= r; }
        return this->normalize();
      }
      lll &operator*=(const lll &r) {
        ll tx = size() - 1, ty = r.size() - 1;
        for(tx = size() - 1; tx >= 0; --tx) {
          if((*this)[tx] > 0) { break; }
        }
        for(ty = r.size() - 1; ty >= 0; --ty) {
          if(r[ty] > 0) { break; }
        }
        lll res(0);
        res.resize(tx + ty + 2);
        if(sign == r.sign) { res.sign = 1; }
        else { res.sign = -1; }
        for(ll i = 0; i <= tx; i++) {
          for(ll j = 0; j <= ty && i + j < res.size() - 1; j++) {
            ll val = (*this)[i] * r[j] + res[i + j];
            res[i + j + 1] += val / lll::BASE;
            res[i + j] = val % lll::BASE;
          }
        }
        return (*this) = res.normalize();
      }
      friend lll POW(const lll &a, ll n) {
        lll r(1), b = a;
        while(n > 0) {
          if(n & 1) { r = r * b; }
          b = b * b;
          n >>= 1;
        }
        return r;
      }
      lll operator+(const lll &r) const { return lll(*this) += r; }
      lll operator-(const lll &r) const { return lll(*this) -= r; }
      lll operator*(ll r) const { return lll(*this) *= r; }
      lll operator*(const lll &r) const { return lll(*this) *= r; }
      lll &operator/=(ll r) {
        if(r < 0) { sign *= -1, r = -r; }
        ll c = 0, t = 0;
        for(ll i = size() - 1; i >= 0; i--) {
          t = lll::BASE * c + (*this)[i];
          (*this)[i] = t / r;
          c = t % r;
        }
        this->normalize();
        return (*this);
      }
      ll operator%=(ll r) {
        if(r < 0) { sign *= -1, r = -r; }
        ll c = 0, t = 0;
        for(ll i = size() - 1; i >= 0; i--) {
          t = lll::BASE * c + (*this)[i];
          (*this)[i] = t / r;
          c = t % r;
        }
        return c;
      }
      lll operator/(ll r) const { return lll(*this) /= r; }
      ll operator%(ll r) const { return lll(*this) %= r; }
      friend pair<lll, lll> divmod(const lll &a, const lll &r) {
        lll zero = 0, s = 0, t = 0;
        if(abs(a) < abs(r)) { return {zero, a}; }
        lll ar = abs(r);
        s.resize(a.size()), t.resize(r.size());
        ll tx = a.size() - 1;
        for(; tx >= 0; --tx) {
          if(a[tx] > 0) { break; }
        }
        for(ll i = tx; i >= 0; i--) {
          t = t * lll::BASE + a[i];
          ll lo = 0, hi = lll::BASE;
          if(t >= ar) {
            while(hi - lo > 1) {
              ll mid = (hi + lo) / 2;
              if(ar * mid > t) hi = mid;
              else lo = mid;
            }
            t -= ar * lo;
          }
          s[i] = lo;
        }
        if(a.sign == r.sign) { s.sign = 1, t.sign = 1; }
        else { s.sign = -1, t.sign = 1; }
        return make_pair(s.normalize(), t.normalize());
      }
      lll operator/(const lll &r) const { return divmod((*this), r).first; }
      lll operator%(const lll &r) const { return divmod((*this), r).second; }
      lll &operator/=(const lll &r) { return (*this) = (*this) / r; }
      lll &operator%=(const lll &r) { return (*this) = (*this) % r; }
      friend bool operator<(const lll &x, const lll &y) {
        if(x.sign < y.sign) { return true; }
        else if(x.sign > y.sign) { return false; }
        else {
          ll tx = x.size() - 1, ty = y.size() - 1;
          for(tx = x.size() - 1; tx >= 0; --tx) {
            if(x[tx] > 0) { break; }
          }
          for(ty = y.size() - 1; ty >= 0; --ty) {
            if(y[ty] > 0) { break; }
          }
          if(tx < ty) { return true; }
          else if(tx > ty) { return false; }
          else if(x.sign == 1) {
            for(ll i = tx; i >= 0; i--) {
              if(x[i] != y[i]) { return x[i] < y[i]; }
            }
            return false;
          }
          else {
            for(ll i = tx; i >= 0; i--) {
              if(x[i] != y[i]) { return x[i] > y[i]; }
            }
            return false;
          }
        }
      }
      friend bool operator>(const lll &x, const lll &y) { return y < x; }
      friend bool operator<=(const lll &x, const lll &y) { return !(x > y); }
      friend bool operator>=(const lll &x, const lll &y) { return !(x < y); }
      friend bool operator==(const lll &x, const lll &y) {
        if(x.sign != y.sign) { return 0; }
        ll tx = (ll)x.size() - 1, ty = (ll)y.size() - 1;
        for(tx = x.size() - 1; tx >= 0; --tx) {
          if(x[tx] > 0) { break; }
        }
        for(ty = y.size() - 1; ty >= 0; --ty) {
          if(y[ty] > 0) { break; }
        }
        if(tx != ty) { return false; }
        for(ll i = tx; i >= 0; i--) {
          if(x[i] != y[i]) { return false; }
        }
        return true;
      }
      friend bool operator!=(const lll &x, const lll &y) { return !(x == y); }
    };

    lll tolll(const string &is) {
      string s = is;
      if(s[0] == '-') { s = s.substr(1); }
      while(s.size() % lll::BASE_D != 0) s = "0" + s;
      ll N = s.size();
      lll res(N / lll::BASE_D, 0);
      for(ll i = 0; i < (ll)s.size(); i++) {
        res[(N - i - 1) / lll::BASE_D] *= 10;
        res[(N - i - 1) / lll::BASE_D] += s[i] - '0';
      }
      if(is[0] == '-') { res.sign = -1; }
      return res;
    }
    string tostr(const lll &r) {
      stringstream ss;
      if(r.sign == -1) { ss << '-'; }
      ll d = r.size() - 1;
      for(; d >= 0; --d) {
        if(r[d] > 0) { break; }
      }
      if(d == -1) { ss << 0; }
      else { ss << r[d]; }
      for(ll i = d - 1; i >= 0; i--) {
        ss.width(lll::BASE_D);
        ss.fill('0');
        ss << r[i];
      }
      return ss.str();
    }

    istream &operator>>(istream &is, lll &x) {
      string s;
      is >> s;
      x = tolll(s);
      return is;
    }
    ostream &operator<<(ostream &os, const lll &x) {
      if(x.sign == -1) { os << '-'; }
      ll d = x.size() - 1;
      for(d = x.size() - 1; d >= 0; --d) {
        if(x[d] > 0) { break; }
      }
      if(d == -1) { os << 0; }
      else { os << x[d]; }
      for(ll i = d - 1; i >= 0; i--) {
        os.width(lll::BASE_D);
        os.fill('0');
        os << x[i];
      }
      return os;
    }
    """

  'Rotate':
    'prefix':'Rotate'
    'body':"""
    auto rotate = [&n]<typename T>(vector<vector<T>> &v) {
      vector<vector<T>> u(n, vector<T>(n));
      for(ll i = 0; i < n; i++) {
        for(ll j = 0; j < n; j++) {
          u[j][n - 1 - i] = v[i][j];
        }
      }
      v = u;
      return;
    };
    """

  'rotate':
    'prefix':'rotate'
    'body':'rotate($1);'

  'ImplicitTreap':
    'prefix':'ImplicitTreap'
    'body':"""
    template<typename T0, typename T1> struct ImplicitTreap {
     private:
      virtual T0 f0(T0, T0) = 0;
      const T0 u0;
      virtual T1 f1(T1, T1) = 0;
      const T1 u1;
      virtual T0 g(T0, T1) = 0;
      virtual T1 p(T1, int) = 0;
      struct xorshift {
        uint64_t x;
        xorshift() {
          mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
          x = rnd();
          for(int i = 0; i < 100; i++) { random(); }
        }
        uint64_t random() {
          x = x ^ (x << 7);
          return x = x ^ (x >> 9);
        }
      } rnd;
      struct Node {
        T0 value, acc;
        T1 lazy;
        int priority, cnt;
        bool rev;
        Node *l, *r;
        Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}
      } *root = nullptr;
      using Tree = Node *;
      int cnt(Tree t) { return t ? t->cnt : 0; }
      T0 acc(Tree t) { return t ? t->acc : u0; }
      void update_cnt(Tree t) {
        if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }
      }
      void update_acc(Tree t) {
        if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }
      }
      void pushup(Tree t) { update_cnt(t), update_acc(t); }
      void pushdown(Tree t) {
        if(t && t->rev) {
          t->rev = false;
          swap(t->l, t->r);
          if(t->l) { t->l->rev ^= 1; }
          if(t->r) { t->r->rev ^= 1; }
        }
        if(t && t->lazy != u1) {
          if(t->l) {
            t->l->lazy = f1(t->l->lazy, t->lazy);
            t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));
          }
          if(t->r) {
            t->r->lazy = f1(t->r->lazy, t->lazy);
            t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));
          }
          t->value = g(t->value, p(t->lazy, 1));
          t->lazy = u1;
        }
        pushup(t);
      }
      void split(Tree t, int key, Tree &l, Tree &r) {
        if(!t) {
          l = r = nullptr;
          return;
        }
        pushdown(t);
        int implicit_key = cnt(t->l) + 1;
        if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }
        else { split(t->r, key - implicit_key, t->r, r), l = t; }
        pushup(t);
      }
      void insert(Tree &t, int key, Tree item) {
        Tree t1, t2;
        split(t, key, t1, t2);
        merge(t1, t1, item);
        merge(t, t1, t2);
      }
      void merge(Tree &t, Tree l, Tree r) {
        pushdown(l);
        pushdown(r);
        if(!l || !r) { t = l ? l : r; }
        else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }
        else { merge(r->l, l, r->l), t = r; }
        pushup(t);
      }
      void erase(Tree &t, int key) {
        Tree t1, t2, t3;
        split(t, key + 1, t1, t2);
        split(t1, key, t1, t3);
        merge(t, t1, t2);
      }
      void update(Tree t, int l, int r, T1 x) {
        if(l >= r) return;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->lazy = f1(t2->lazy, x);
        t2->acc = g(t2->acc, p(x, cnt(t2)));
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      T0 query(Tree t, int l, int r) {
        if(l == r) return u0;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        T0 ret = t2->acc;
        merge(t2, t2, t3);
        merge(t, t1, t2);
        return ret;
      }
      int find(Tree t, T0 x, int offset, bool left = true) {
        if(f0(t->acc, x) == x) { return -1; }
        else {
          if(left) {
            if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }
          }
          else {
            if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }
          }
        }
      }
      void reverse(Tree t, int l, int r) {
        if(l > r) { return; }
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->rev ^= 1;
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      void rotate(Tree t, int l, int m, int r) {
        reverse(t, l, r);
        reverse(t, l, l + r - m);
        reverse(t, l + r - m, r);
      }
      void dump(Tree t) {
        if(!t) return;
        pushdown(t);
        dump(t->l);
        cout << t->value << " ";
        dump(t->r);
      }

     public:
      ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}
      void set_by_vector(const vector<T0> &a) {
        for(int i = 0; i < a.size(); i++) {
          insert(i, a[i]);
        }
      }
      int size() { return cnt(root); }
      void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }
      void update(int l, int r, T1 x) { update(root, l, r, x); }
      T0 query(int l, int r) { return query(root, l, r); }
      int binary_search(int l, int r, T0 x, bool left = true) {
        if(l >= r) return -1;
        Tree t1, t2, t3;
        split(root, l, t1, t2);
        split(t2, r - l, t2, t3);
        int ret = find(t2, x, l, left);
        merge(t2, t2, t3);
        merge(root, t1, t2);
        return ret;
      }
      void erase(int pos) { erase(root, pos); }
      void reverse(int l, int r) { reverse(root, l, r); }
      void rotate(int l, int m, int r) { rotate(root, l, m, r); }
      void dump() {
        dump(root);
        cout << endl;
      }
      T0 operator[](int pos) { return query(pos, pos + 1); }
    };

    /*
    int size() : O(1)
    void insert(int pos, T0 x)       : 先頭から pos の位置 (pos == 0 なら先頭)に x を挿入 O(logn)
    void update(int l, int r, T1 x)  : [l,r) に x を作用　O(logn)
    T0 query(int l, int r)           : [l,r) の累積 O(logn)
    void erase(int pos)              : 位置 pos を削除 O(logn)
    void reverse(int l, int r)       : [l,r) を反転 O(logn)
    void rotate(int l, int m, int r) : [l,r) の先頭が m になるよう回転
    T0 operator[]                    : ランダムアクセス O(logn)
    void dump()                      : 配列の中身を print (debug用)
    int binary_search(int l, int r, T0 x, bool left = true) :
      k∈[l, r) で f0(tr[k], x) != x となる最左/右のもの。存在しない場合は-1 O(logn)
      ex) MinMonoidの場合、x未満の最左/最右の要素の位置を返す
    */
    """

  'ImplicitTreap_Update_Min':
    'prefix':'ImplicitTreap_Update_Min'
    'body':"""
    template<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x; }
    };
    """

  'ImplicitTreap_Add_Sum':
    'prefix':'ImplicitTreap_Add_Sum'
    'body':"""
    template<typename T0, typename T1> struct AddSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AddSumQuery(): AddSumQuery(0, 0) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return x + y; }
      T0 g(T0 x, T1 y) override { return x + y; }
      T1 p(T1 x, int len) override { return x * len; }
    };
    """

  'ImplicitTreap_Add_Min':
    'prefix':'ImplicitTreap_Add_Min'
    'body':"""
    template<typename T0, typename T1> struct AddMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AddMinQuery(): AddMinQuery(numeric_limits<T0>::max(), 0) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return x + y; }
      T0 g(T0 x, T1 y) override { return x + y; }
      T1 p(T1 x, int len) override { return x; }
    };
    """

  'ImplicitTreap_Update_Sum':
    'prefix':'ImplicitTreap_Update_Sum'
    'body':"""
    template<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }
    };
    """

  'ImplicitTreap_Affine_Sum':
    'prefix':'ImplicitTreap_Affine_Sum'
    'body':"""
    template<typename T0> struct AffineSumQuery : public ImplicitTreap<T0, pair<T0, T0>> {
      using T1 = pair<T0, T0>;  // first * x + second
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AffineSumQuery(): AffineSumQuery(0, {1, 0}) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }
      T0 g(T0 x, T1 y) override { return y.first * x + y.second; }
      T1 p(T1 x, int len) override { return {x.first, x.second * len}; }
      // update(i, j, {a, b}); // [i, j)にax + bを作用
      // update(i, j, {0, a}); // update
      // update(i, j, {1, a}); // 加算
      // update(i, j, {a, 0}); // 倍
    };
    """

  'ImplicitTreap_Affine_MinMax':
    'prefix':'ImplicitTreap_Affine_MinMax'
    'body':"""
    template<typename T> struct AffineMinMaxQuery : public ImplicitTreap<pair<T, T>, pair<T, T>> {
      using T0 = pair<T, T>;  // {min, max}
      using T1 = pair<T, T>;  // first * x + second
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AffineMinMaxQuery(): AffineMinMaxQuery({numeric_limits<T>::max(), -numeric_limits<T>::max()}, {1, 0}) {
      }
      T0 f0(T0 x, T0 y) override { return {min(x.first, y.first), max(x.second, y.second)}; }
      T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }
      T0 g(T0 x, T1 y) override {
        T0 ret = {x.first * y.first + y.second, x.second * y.first + y.second};
        if(y.first < 0) swap(ret.first, ret.second);
        return ret;
      }
      T1 p(T1 x, int len) override { return x; }
      // update(i, j, {a, b}); // [i, j)にax + bを作用
      // update(i, j, {0, a}); // update
      // update(i, j, {1, a}); // 加算
      // update(i, j, {a, 0}); // 倍
    };
    """

  'PrioritySum_super':
    'prefix':'PrioritySum_super'
    'body':"""
    using S = pair<ll, ll>;
    S op(S l, S r) { return {l.first + r.first, l.second + r.second}; }
    S e() { return {0, 0}; }
    ll tar;
    bool F(S x) { return tar > x.second; }

    struct PrioritySum {
      ll n;
      segtree<S, op, e> seg;
      set<ll> s;
      map<ll, ll> comp;
      vector<ll> inv;
      bool builded = false;
      PrioritySum() {}
      void use(ll x) {
        assert(!builded);
        s.insert(x);
      }
      void build() {
        assert(!builded);
        builded = true;
        n = ssize(s);
        seg = segtree<S, op, e>(n);
        ll idx = 0;
        for(auto &i : s) {
          comp[i] = idx;
          inv.emplace_back(i);
          idx++;
        }
      }
      void insert(ll x, ll c = 1) {
        assert(builded);
        auto it = comp.find(x);
        assert(it != comp.end());
        ll idx = it->second;
        auto [sum, cnt] = seg.get(idx);
        seg.set(idx, {sum + x * c, cnt + c});
      }
      void erase(ll x, ll c = 1) { insert(x, -c); }
      ll min(ll k) {
        assert(builded);
        tar = k;
        ll idx = seg.max_right<F>(0);
        assert(idx <= n);
        auto [sum, cnt] = seg.prod(0, idx);
        sum += inv[idx] * (k - cnt);
        return sum;
      }
      ll max(ll k) {
        assert(builded);
        tar = k;
        ll idx = seg.min_left<F>(n) - 1;
        assert(idx >= 0);
        auto [sum, cnt] = seg.prod(idx, n);
        sum -= inv[idx] * (cnt - k);
        return sum;
      }
    } s;
    """

  'PairQuery':
    'prefix':'_PairQuery'
    'body':"""
    template<typename T0, typename T1> struct ImplicitTreap {
     private:
      virtual T0 f0(T0, T0) = 0;
      const T0 u0;
      virtual T1 f1(T1, T1) = 0;
      const T1 u1;
      virtual T0 g(T0, T1) = 0;
      virtual T1 p(T1, int) = 0;
      struct xorshift {
        uint64_t x;
        xorshift() {
          mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
          x = rnd();
          for(int i = 0; i < 100; i++) { random(); }
        }
        uint64_t random() {
          x = x ^ (x << 7);
          return x = x ^ (x >> 9);
        }
      } rnd;
      struct Node {
        T0 value, acc;
        T1 lazy;
        int priority, cnt;
        bool rev;
        Node *l, *r;
        Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}
      } *root = nullptr;
      using Tree = Node *;
      int cnt(Tree t) { return t ? t->cnt : 0; }
      T0 acc(Tree t) { return t ? t->acc : u0; }
      void update_cnt(Tree t) {
        if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }
      }
      void update_acc(Tree t) {
        if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }
      }
      void pushup(Tree t) { update_cnt(t), update_acc(t); }
      void pushdown(Tree t) {
        if(t && t->rev) {
          t->rev = false;
          swap(t->l, t->r);
          if(t->l) { t->l->rev ^= 1; }
          if(t->r) { t->r->rev ^= 1; }
        }
        if(t && t->lazy != u1) {
          if(t->l) {
            t->l->lazy = f1(t->l->lazy, t->lazy);
            t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));
          }
          if(t->r) {
            t->r->lazy = f1(t->r->lazy, t->lazy);
            t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));
          }
          t->value = g(t->value, p(t->lazy, 1));
          t->lazy = u1;
        }
        pushup(t);
      }
      void split(Tree t, int key, Tree &l, Tree &r) {
        if(!t) {
          l = r = nullptr;
          return;
        }
        pushdown(t);
        int implicit_key = cnt(t->l) + 1;
        if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }
        else { split(t->r, key - implicit_key, t->r, r), l = t; }
        pushup(t);
      }
      void insert(Tree &t, int key, Tree item) {
        Tree t1, t2;
        split(t, key, t1, t2);
        merge(t1, t1, item);
        merge(t, t1, t2);
      }
      void merge(Tree &t, Tree l, Tree r) {
        pushdown(l);
        pushdown(r);
        if(!l || !r) { t = l ? l : r; }
        else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }
        else { merge(r->l, l, r->l), t = r; }
        pushup(t);
      }
      void erase(Tree &t, int key) {
        Tree t1, t2, t3;
        split(t, key + 1, t1, t2);
        split(t1, key, t1, t3);
        merge(t, t1, t2);
      }
      void update(Tree t, int l, int r, T1 x) {
        if(l >= r) return;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->lazy = f1(t2->lazy, x);
        t2->acc = g(t2->acc, p(x, cnt(t2)));
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      T0 query(Tree t, int l, int r) {
        if(l == r) return u0;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        T0 ret = t2->acc;
        merge(t2, t2, t3);
        merge(t, t1, t2);
        return ret;
      }
      int find(Tree t, T0 x, int offset, bool left = true) {
        if(f0(t->acc, x) == x) { return -1; }
        else {
          if(left) {
            if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }
          }
          else {
            if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }
          }
        }
      }
      void reverse(Tree t, int l, int r) {
        if(l > r) { return; }
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->rev ^= 1;
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      void rotate(Tree t, int l, int m, int r) {
        reverse(t, l, r);
        reverse(t, l, l + r - m);
        reverse(t, l + r - m, r);
      }
      void dump(Tree t) {
        if(!t) return;
        pushdown(t);
        dump(t->l);
        cout << t->value << " ";
        dump(t->r);
      }

     public:
      ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}
      void set_by_vector(const vector<T0> &a) {
        for(int i = 0; i < a.size(); i++) {
          insert(i, a[i]);
        }
      }
      int size() { return cnt(root); }
      void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }
      void update(int l, int r, T1 x) { update(root, l, r, x); }
      T0 query(int l, int r) { return query(root, l, r); }
      int binary_search(int l, int r, T0 x, bool left = true) {
        if(l >= r) return -1;
        Tree t1, t2, t3;
        split(root, l, t1, t2);
        split(t2, r - l, t2, t3);
        int ret = find(t2, x, l, left);
        merge(t2, t2, t3);
        merge(root, t1, t2);
        return ret;
      }
      void erase(int pos) { erase(root, pos); }
      void reverse(int l, int r) { reverse(root, l, r); }
      void rotate(int l, int m, int r) { rotate(root, l, m, r); }
      void dump() {
        dump(root);
        cout << endl;
      }
      T0 operator[](int pos) { return query(pos, pos + 1); }
    };

    template<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }
    };

    template<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x; }
    };

    namespace std {
    template<typename T0, typename T1> class numeric_limits<pair<T0, T1>>
    {
     public:
      static constexpr pair<T0, T1> min() { return {numeric_limits<T0>::min(), numeric_limits<T1>::min()}; }
      static constexpr pair<T0, T1> max() { return {numeric_limits<T0>::max(), numeric_limits<T1>::max()}; }
    };
    }  // namespace std

    template<typename T0, typename T1, bool ascending = true> struct PairQuery {
      UpdateSumQuery<T1, T1> tr;
      UpdateMinQuery<pair<T0, T1>, pair<T0, T1>> tr2;
      int cnt = 0;
      void insert(const pair<T0, T1> &a) {
        int p = tr2.binary_search(0, tr2.size(), a, !ascending);
        if(ascending) {
          tr.insert(p + 1, a.second);
          tr2.insert(p + 1, a);
        }
        else {
          if(p == -1) {
            tr.insert(tr.size(), a.second);
            tr2.insert(tr2.size(), a);
          }
          else {
            tr.insert(p, a.second);
            tr2.insert(p, a);
          }
        }
        cnt++;
      }
      // 第一要素がxのものとxより左側のものに対し第二要素の累積を返す
      T1 query(T0 x) {
        if(ascending) {
          int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::max()}, false);
          p++;
          return tr.query(0, p);
        }
        else {
          int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::min()});
          if(p == -1) p = cnt;
          return tr.query(0, p);
        }
      }
      void erase_at(int k) {
        assert(0 <= k && k < cnt);
        tr.erase(k);
        tr2.erase(k);
        cnt--;
      }
      void erase(const pair<T0, T1> &a) {
        int p = tr2.binary_search(0, tr2.size(), a, !ascending);
        if(ascending) { p++; }
        else {
          if(p == -1) p = cnt;
          p--;
        }
        assert(0 <= p && p < cnt && tr2[p] == a);
        erase_at(p);
      }
      int size() const { return cnt; }
      T1 sum(int k) { return tr.query(0, k); }
      pair<T0, T1> operator[](int k) { return tr2[k]; }
      void dump() { tr2.dump(); }
      T1 operator()(int k) { return sum(k); }
    };

    template<typename T> using MaxSum = PairQuery<T, T, false>;
    template<typename T> using MinSum = PairQuery<T, T, true>;
    """

  'array':
    'prefix':'array'
    'body':'array<ll,$1>$2'

  'va':
    'prefix':'va'
    'body':'vector<array<ll,$1>>$2'

  'GCDCNT':
    'prefix':'GCDCNT'
    'body':"""
    // val = (k∈[1,n] で gcd(n, k) == key を満たすものの個数)
    map<ll, ll> GCDCNT(ll n) {
      vector<ll> div;
      for(ll i = 1; i*i <= n; i++) {
        if(n % i == 0) {
          div.emplace_back(i);
          if(i * i != n) { div.emplace_back(n / i); }
        }
      }
      ranges::sort(div, ranges::greater());
      ll s = ssize(div);
      map<ll, ll> r;
      for(ll i = 0; i < s; i++) {
        r[div[i]] = n / div[i];
        for(ll j = 0; j < i; j++) {
          if(div[j] % div[i] == 0) { r[div[i]] -= r[div[j]]; }
        }
      }
      return r;
    }
    """

  'gcdcnt':
    'prefix':'gcdcnt'
    'body':'auto g=GCDCNT($1);'

  'bit':
    'prefix':'bit'
    'body':'${1:i}&1<<${2:j}'

  'PrimeEnum':
    'prefix':'PrimeEnum'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }
    """

  'primeenum':
    'prefix':'primeenum'
    'body':'auto p=PrimeEnum($1);$2'

  'zeta_mobius':
    'prefix':'zeta_mobius'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    struct DivisorTransform {
      template<typename T> static void zeta_transform(vector<T> &v) {
        ll n = ssize(v) - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }
        }
      }
      template<typename T> static void mobius_transform(vector<T> &v) {
        ll n = ssize(v) - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }
        }
      }
      template<typename I, typename T> static void zeta_transform(map<I, T> &m) {
        for(auto p = m.rbegin(); p != m.rend(); p++) {
          for(auto &x : m) {
            if(p->first == x.first) { break; }
            if(p->first % x.first == 0) { p->second += x.second; }
          }
        }
      }
      template<typename I, typename T> static void mobius_transform(map<I, T> m) {
        for(auto &x : m) {
          for(auto p = m.rbegin(); p != m.rend(); p++) {
            if(x.first == p->first) { break; }
            if(p->first % x.first == 0) { p->second -= x.second; }
          }
        }
      }
    };

    struct MultipleTransform {
      template<typename T> static void zeta_transform(vector<T> &v) {
        ll n = ssize(v) - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }
        }
      }
      template<typename T> static void mobius_transform(vector<T> &v) {
        ll n = ssize(v) - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }
        }
      }
      template<typename I, typename T> static void zeta_transform(map<I, T> &m) {
        for(auto &x : m) {
          for(auto p = m.rbegin(); p->first != x.first; p++) {
            if(p->first % x.first == 0) { x.second += p->second; }
          }
        }
      }
      template<typename I, typename T> static void mobius_transform(map<I, T> &m) {
        for(auto p1 = m.rbegin(); p1 != m.rend(); p1++) {
          for(auto p2 = m.rbegin(); p2 != p1; p2++) {
            if(p2->first % p1->first == 0) { p1->second -= p2.second; }
          }
        }
      }
    };
    """

  'GCD_convolution':
    'prefix':'GCD_convolution'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    template<typename T> vector<T> GCD_convolution(const vector<T> &a, const vector<T> &b) {
      assert(ssize(a) == ssize(b));
      auto n = ssize(a) - 1, s = a, t = b, P = PrimeEnum(n);
      auto zeta_transform = [&](vector<T> &v) {
        for(auto &p : P) {
          for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }
        }
      };
      auto mobius_transform = [&](vector<T> &v) {
        for(auto &p : P) {
          for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }
        }
      };
      zeta_transform(s);
      zeta_transform(t);
      for(ll i = 0; i <= n; i++) { s[i] *= t[i]; }
      mobius_transform(s);
      return s;
    }
    """

  'LCM_convolution':
    'prefix':'LCM_convolution'
    'body':"""
    template<typename T> vector<T> LCM_convolution(const vector<T> &a, const vector<T> &b) {
      assert(ssize(a) == ssize(b));
      auto n = ssize(a) - 1, s = a, t = b, P = PrimeEnum(n);
      auto zeta_transform = [&](vector<T> &v) {
        for(auto &p : P) {
          for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }
        }
      };
      auto mobius_transform = [&](vector<T> &v) {
        for(auto &p : P) {
          for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }
        }
      };
      zeta_transform(s);
      zeta_transform(t);
      for(ll i = 0; i <= n; i++) { s[i] *= t[i]; }
      mobius_transform(s);
      return s;
    }
    """

  'chmax':
    'prefix':'chmax'
    'body':'$1=max($1,$2);$3'

  'chmin':
    'prefix':'chmin'
    'body':'$1=min($1,$2);$3'

  'BinaryTreePathCount':
    'prefix':'BinaryTreePathCount'
    'body':"""
    vector<mint> BinaryTreePathCount(ll n) {
      ll D = 63 - __builtin_clzll(n + 1), L = n - (1LL << D) + 1;
      vector<mint> cnt(130), bin(130, 1);
      for(ll i = 1; i < 130; i++) { bin[i] = bin[i] * 2; }
      map<ll, mint> memo[65][130];
      for(ll k = 0; k < 130; k++) {
        auto calc = [&](auto &&calc, ll d, ll l) -> mint {
          if(!d) { return 0; }
          if(memo[d][k].contains(l)) { return memo[d][k][l]; }
          mint r = 0;
          if(k < d) {
            r = bin[k];
            if(k >= 2) { r += bin[k - 2] * (k - 1); }
          }
          else if(k >= 2) { r += bin[k - 2] * max(0LL, d * 2 - k - 1); }
          ll t = 1LL << d - 1;
          if(l >= t) {
            r += calc(calc, d, 0) + calc(calc, d - 1, l - t);
            if(k == d) { r += l; }
            else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }
            else if(k == d * 2) { r += mint(t) * (l - t); }
          }
          else {
            r += calc(calc, d - 1, l) + calc(calc, d - 1, 0);
            if(k == d) { r += l; }
            else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }
          }
          return memo[d][k][l] = r;
        };
        cnt[k] = calc(calc, D, L);
      }
      return cnt;
    }
    """

  'binarytreepathcount':
    'prefix':'binarytreepathcount'
    'body':'BinaryTreePathCount($1)'

  's1':
    'prefix':'s1'
    'body':'string ${1:s}; cin>>${1:s};$2'

  's2':
    'prefix':'s2'
    'body':'string ${1:s},${2:t}; cin>>${1:s}>>${2:t};$3'

  'assign':
    'prefix':'assign'
    'body':'assign($1,$2);$3'

  'secsort':
    'prefix':'secsort'
    'body':'ranges::sort($1, {}, &pair<ll, ll>::second);$2'

  'Maxedge':
    'prefix':'Maxedge'
    'body':"""
    vector<vector<ll>> mx(n, vector<ll>(24, 0));
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      mx[v][0] = d;
      for(auto &[nv, w] : g[v]) {
        if(nv == p) { continue; }
        DFS(DFS, nv, v, w);
      }
    };
    DFS(DFS, 0, -1, 0);
    for(ll j = 0; j < 23; j++) {
      for(ll i = 0; i < n; i++) {
        ll nx = t.bl[i][j];
        if(nx != -1) { mx[i][j + 1] = max(mx[i][j], mx[nx][j]); }
      }
    }
    auto maxedge = [&](ll u, ll v) -> ll {
      ll l = t.lca(u, v);
      auto maxedge_lca = [&](ll v, ll l) {
        ll d = t.depth(v) - t.depth(l), r = 0;
        while(d) {
          ll tmp = __builtin_ctz(d);
          r = max(r, mx[v][tmp]);
          v = t.bl[v][tmp];
          d ^= 1 << tmp;
        }
        return r;
      };
      return max(maxedge_lca(v, l), maxedge_lca(u, l));
    };
    """

  'maxedge':
    'prefix':'maxedge'
    'body':'maxedge($1,$2)'

  'Minedge':
    'prefix':'Minedge'
    'body':"""
    vector<vector<ll>> mn(n, vector<ll>(24, 0));
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      mn[v][0] = d;
      for(auto &[nv, w] : g[v]) {
        if(nv == p) { continue; }
        DFS(DFS, nv, v, w);
      }
    };
    DFS(DFS, 0, -1, 0);
    for(ll j = 0; j < 23; j++) {
      for(ll i = 0; i < n; i++) {
        ll nx = t.bl[i][j];
        if(nx != -1) { mn[i][j + 1] = min(mn[i][j], mn[nx][j]); }
      }
    }
    auto minedge = [&](ll u, ll v) -> ll {
      ll l = t.lca(u, v);
      auto minedge_lca = [&](ll v, ll l) {
        ll d = t.depth(v) - t.depth(l), r = 1e18;
        while(d) {
          ll tmp = __builtin_ctz(d);
          r = min(r, mn[v][tmp]);
          v = t.bl[v][tmp];
          d ^= 1 << tmp;
        }
        return r;
      };
      return min(minedge_lca(v, l), minedge_lca(u, l));
    };
    """

  'minedge':
    'prefix':'minedge'
    'body':'minedge($1,$2)'

  'stable_sort':
    'prefix':'stable_sort'
    'body':'ranges::stable_sort($1);$2'

  'subset':
    'prefix':'subset'
    'body':'for(ll j = i; j > 0; j = (j - 1) & i) {$1}$2'

  'superset':
    'prefix':'superset'
    'body':'for(ll j = i; j < 1 << n; j = (j + 1) | i){$1}$2'

  'AND_convolution':
    'prefix':'AND_convolution'
    'body':"""
    template<typename T> AND_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert((n & (n - 1)) == 0);
      auto superset_zeta_transform = [&](vector<T> &v) {
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] += v[j + k + i]; }
          }
        }
      };
      auto superset_mobius_transform = [&](vector<T> &v) {
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] -= v[j + k + i]; }
          }
        }
      };
      superset_zeta_transform(a);
      superset_zeta_transform(b);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      superset_mobius_transform(a);
      return a;
    }
    """

  'OR_convolution':
    'prefix':'OR_convolution'
    'body':"""
    template<typename T> OR_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert((n & (n - 1)) == 0);
      auto subset_zeta_transform = [&](vector<T> &v) {
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] += v[j + k]; }
          }
        }
      };
      auto subset_mobius_transform = [&](vector<T> &v) {
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] -= v[j + k]; }
          }
        }
      };
      subset_zeta_transform(a);
      subset_zeta_transform(b);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      subset_mobius_transform(a);
      return a;
    }
    """

  'XOR_convolution':
    'prefix':'XOR_convolution'
    'body':"""
    template<typename T> XOR_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert((n & (n - 1)) == 0);
      auto fast_walsh_hadamard_transform = [&](vector<T> &v, bool inv) {
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) {
              T s = v[j + k], t = v[j + k + i];
              v[j + k] = s + t;
              v[j + k + i] = s - t;
            }
          }
        }
        if(inv) {
          T inv_n = T(1) / n;
          for(auto &x : v) { x *= inv_n; }
        }
      };
      fast_walsh_hadamard_transform(a, false);
      fast_walsh_hadamard_transform(b, false);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      fast_walsh_hadamard_transform(a, true);
      return a;
    }
    """

  'mymin':
    'prefix':'mymin'
    'body':'*ranges::min_element($1,[&](auto x,auto y){return $2;});$3 // condition to get x'

  'CommonInterval':
    'prefix':'CommonInterval'
    'body':'auto CI = [](pair<ll, ll> x, pair<ll, ll> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); };'

  'LongestCommonInterval':
    'prefix':'LongestCommonInterval'
    'body':"""
    template<typename T> T LCI(vector<pair<T, T>> v) {
      ll n = ssize(v);
      ranges::sort(v);
      T m = v[0].second, r = 0;
      for(ll i = 1; i < n; i++) {
        r = max(r, min(m, v[i].second) - v[i].first);
        m = max(m, v[i].second);
      }
      return r;
    }
    """

  'ShortestCommonInterval':
    'prefix':'ShortestCommonInterval'
    'body':"""
    template<typename T> vector<T> SCI(vector<pair<T, T>> &v) {
      auto CI = [](pair<T, T> x, pair<T, T> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); };
      pair<T, T> l, r, p;
      l = *ranges::min_element(v, [&](auto x, auto y) { return x.first > y.first; });
      r = *ranges::min_element(v, [&](auto x, auto y) { return x.second < y.second; });
      p = *ranges::min_element(v, [&](auto x, auto y) { return x.second - x.first < y.second - y.first; });

      vector<T> sci;
      for(auto &i : v) { sci.emplace_back(min({CI(i, l), CI(i, r), CI(i, p)})); }
      return sci;
    }
    """

  'count_if':
    'prefix':'count_if'
    'body':'ranges::count_if($1,[&](auto x){return $2;})'

  'MEX':
    'prefix':'MEX'
    'body':"""
    struct MEX {
      set<pair<ll, ll>> s;
      MEX() {
        s.emplace(-1e18, -1e18);
        s.emplace(1e18, 1e18);
      }
      bool contains(ll x) const {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        return l <= x && x <= r;
      }
      bool insert(ll x) {
        auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);
        auto [l, r] = *it;
        auto [nl, nr] = *nit;
        if(l <= x && x <= r) { return false; }
        if(r == x - 1) {
          if(nl == x + 1) {
            s.erase(it);
            s.erase(nit);
            s.emplace(l, nr);
          }
          else {
            s.erase(it);
            s.emplace(l, x);
          }
        }
        else {
          if(nl == x + 1) {
            s.erase(nit);
            s.emplace(x, nr);
          }
          else { s.emplace(x, x); }
        }
        return true;
      }
      void erase(ll x) {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        s.erase(it);
        if(l != x) { s.emplace(l, x - 1); }
        if(r != x) { s.emplace(x + 1, r); }
      }
      ll query(ll x = 0) const {
        auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));
        return l <= x && x <= r ? r + 1 : x;
      }
    } mex;
    """

  'SlopeTrick':
    'prefix':'SlopeTrick'
    'body':"""
    struct SlopeTrick {
      ll min_f, add_l, add_r;
      priority_queue<ll> L;
      priority_queue<ll, vector<ll>, greater<ll>> R;

     private:
      void push_R(const ll &a) { R.emplace(a - add_r); }
      ll top_R() const { return R.empty() ? 1e18 : R.top() + add_r; }
      ll pop_R() {
        ll val = top_R();
        if(!R.empty()) { R.pop(); }
        return val;
      }
      void push_L(const ll &a) { L.emplace(a - add_l); }
      ll top_L() const { return L.empty() ? -1e18 : L.top() + add_l; }
      ll pop_L() {
        ll val = top_L();
        if(!L.empty()) { L.pop(); }
        return val;
      }
      size_t size() { return L.size() + R.size(); }

     public:
      SlopeTrick(): min_f(0), add_l(0), add_r(0) {}
      struct Query {
        ll lx, rx, min_f;
      };
      Query query() const { return (Query){top_L(), top_R(), min_f}; }
      void add_all(const ll &a) { min_f += a; }
      void add_a_x(const ll &a) {
        min_f += max(0LL, a - top_R());
        push_R(a);
        push_L(pop_R());
      }
      void add_x_a(const ll &a) {
        min_f += max(0LL, top_L() - a);
        push_L(a);
        push_R(pop_L());
      }
      void add_abs(const ll &a) {
        add_a_x(a);
        add_x_a(a);
      }
      void clear_right() {
        while(!R.empty()) { R.pop(); }
      }
      void clear_left() {
        while(!L.empty()) { L.pop(); }
      }
      void shift(const ll &a, const ll &b) {
        assert(a <= b);
        add_l += a;
        add_r += b;
      }
      void shift(const ll &a) { shift(a, a); }
      ll get(const ll &x) {
        ll r = min_f;
        while(!L.empty()) { r += max(0LL, pop_L() - x); }
        while(!R.empty()) { r += max(0LL, x - pop_R()); }
        return r;
      }
      void merge(SlopeTrick &st) {
        if(st.size() > size()) {
          swap(st.L, L);
          swap(st.R, R);
          swap(st.add_l, add_l);
          swap(st.add_r, add_r);
          swap(st.min_f, min_f);
        }
        while(!st.R.empty()) { add_x_a(st.pop_R()); }
        while(!st.L.empty()) { add_a_x(st.pop_L()); }
        min_f += st.min_f;
      }
    }st;
    // https://ei1333.github.io/library/structure/others/slope-trick.hpp
    """

  'slopetrick':
    'prefix':'slopetrick'
    'body':'SlopeTrick st;'

  'Root':
    'prefix':'Root'
    'body':"""
    uint64_t root(uint64_t a, int k) {
      if(a <= 1 || k == 1) { return a; }
      if(k >= 64) { return 1; }
      auto check = [&](__uint128_t n) {
        __uint128_t x = 1, m = n;
        for(ll p = k; p; p >>= 1, m *= m) {
          if(p & 1) { x *= m; }
        }
        return x <= a;
      };
      uint64_t n = powl(a, (long double)(1.0) / k);
      while(!check(n)) { --n; }
      while(check(n + 1)) { ++n; }
      return n;
    }
    """

  'root':
    'prefix':'root'
    'body':'root($1,$2)'

  'Interval':
    'prefix':'Interval'
    'body':"""
    struct Interval {
      set<pair<ll, ll>> s;
      ll cnt;
      Interval(): cnt(0) {
        s.emplace(-1e18, -1e18);
        s.emplace(1e18, 1e18);
      }
      bool contains(ll l, ll r) const {
        assert(l <= r);
        auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));
        return L <= l && r <= R;
      }
      bool contains(ll x) const { return contains(x, x); }
      pair<ll, ll> covered_by(ll l, ll r) const {
        assert(l <= r);
        auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));
        if(L <= l && r <= R) { return {L, R}; }
        return {-1e18, -1e18};
      }
      pair<ll, ll> covered_by(ll x) const { return covered_by(x, x); }
      ll insert(ll l, ll r) {
        assert(l <= r);
        auto it = prev(s.lower_bound({l + 1, l + 1}));
        if(it->first <= l && r <= it->second) { return 0; }
        ll sum_erased = 0;
        if(it->first <= l && l <= it->second + 1) {
          l = it->first;
          sum_erased += it->second - it->first + 1;
          it = s.erase(it);
        }
        else it = next(it);
        while(r > it->second) {
          sum_erased += it->second - it->first + 1;
          it = s.erase(it);
        }
        if(it->first - 1 <= r && r <= it->second) {
          sum_erased += it->second - it->first + 1;
          r = it->second;
          s.erase(it);
        }
        s.emplace(l, r);
        cnt += r - l + 1 - sum_erased;
        return r - l + 1 - sum_erased;
      }
      ll insert(ll x) {
        auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);
        auto [l, r] = *it;
        auto [nl, nr] = *nit;
        if(l <= x && x <= r) { return 0; }
        if(r == x - 1) {
          if(nl == x + 1) {
            s.erase(it);
            s.erase(nit);
            s.emplace(l, nr);
          }
          else {
            s.erase(it);
            s.emplace(l, x);
          }
        }
        else {
          if(nl == x + 1) {
            s.erase(nit);
            s.emplace(x, nr);
          }
          else { s.emplace(x, x); }
        }
        cnt++;
        return 1;
      }
      ll erase(ll l, ll r) {
        assert(l <= r);
        auto it = prev(s.lower_bound({l + 1, l + 1}));
        if(it->first <= l && r <= it->second) {
          if(it->first < l) { s.emplace(it->first, l - 1); }
          if(r < it->second) { s.emplace(r + 1, it->second); }
          s.erase(it);
          cnt -= r - l + 1;
          return r - l + 1;
        }
        ll ret = 0;
        if(it->first <= l && l <= it->second) {
          ret += it->second - l + 1;
          if(it->first < l) { s.emplace(it->first, l - 1); }
          it = s.erase(it);
        }
        else it = next(it);
        while(it->second <= r) {
          ret += it->second - it->first + 1;
          it = s.erase(it);
        }
        if(it->first <= r && r <= it->second) {
          ret += r - it->first + 1;
          if(r < it->second) { s.emplace(r + 1, it->second); }
          s.erase(it);
        }
        cnt -= ret;
        return ret;
      }
      ll erase(ll x) {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        if(!(l <= x && x <= r)) { return 0; }
        s.erase(it);
        if(l != x) { s.emplace(l, x - 1); }
        if(r != x) { s.emplace(x + 1, r); }
        cnt--;
        return 1;
      }
      int size() const { return (int)s.size() - 2; }
      ll count() const { return cnt; }
      ll mex(ll x = 0) const {
        auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));
        return l <= x && x <= r ? r + 1 : x;
      }
      bool same(ll x, ll y) const {
        auto ix = covered_by(x).first, iy = covered_by(y).first;
        return ix == iy && ix != -1e18;
      }
      void dump() const {
        for(auto &[l, r] : s) {
          if(l == -1e18 || r == 1e18) { continue; }
          cout << "[" << l << ", " << r << "] ";
        }
        cout << "\\\\n";
      }
    } I;

    /*
    bool contains(l,r)/(x) : return if [l,r]/x is covered
    pi covered_by(l,r)/(x) : return interval [l,r]/x is covered or {-1e18,-1e18}
    ll insert(l,r)/(x)     : insert [l,r]/x, return Δcnt
    ll erase(l,r)/(x)      : erase(l,r)/x, return -Δcnt
    int size()             : return the number of interval
    ll count()             : return the number of integer contained
    ll mex(x = 0)          : return mex[x, inf)
    bool same(x,y)         : return if x and y are covered by same interval
    void dump()            : debug
    */
    """

  'unsigned long long':
    'prefix':'ull'
    'body':'unsigned long long'

  'Time':
    'prefix':'Time'
    'body':"""
    struct Time {
      int lim;
      chrono::system_clock::time_point t;
      Time(int lim): lim(lim){};
      void start() { t = chrono::system_clock::now(); }
      void end() {
        auto d = chrono::system_clock::now() - t;
        auto msec = chrono::duration_cast<chrono::milliseconds>(d).count();
        cerr << "\\\\n-------------------------------\\\\n";
        if(msec <= lim) {
          cerr << "[\\\\033[36mi\\\\033[m] ";
          cerr << "\\\\033[36mExecution Time : " << msec << " ms\\\\033[m\\\\n";
        }
        else {
          cerr << "[\\\\033[33m!\\\\033[m] ";
          cerr << "\\\\033[33mExecution Time : " << msec << " ms\\\\033[m\\\\n";
        }
        cerr << "-------------------------------\\\\n";
      }
    } Time(2000);
    """

  'RollingHash':
    'prefix':'RollingHash'
    'body':"""
    struct Modint2_61 {
      static constexpr unsigned long long MOD = (1ULL << 61) - 1;
      unsigned long long x;
      constexpr Modint2_61(): x(0ULL) {}
      constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }
      unsigned long long val() const noexcept { return x; }
      Modint2_61 operator-() const { return Modint2_61(MOD - x); }
      Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }
      Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }
      Modint2_61 operator*(const Modint2_61 &a) const {
        __uint128_t r = __uint128_t(x) * a.x;
        r = (r >> 61) + (r & MOD);
        return Modint2_61(r);
      }
      Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }
      Modint2_61 pow(ll n) const {
        if(n < 0) { return inv().pow(-n); }
        Modint2_61 r(1), t = *this;
        while(n) {
          if(n & 1) { r *= t; }
          t *= t;
          n >>= 1;
        }
        return r;
      }
      Modint2_61 inv() const { return pow(MOD - 2); }
      Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }
      Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }
      Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }
      Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }
      template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }
      template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }
      template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }
      template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }
      explicit operator bool() const { return x; }
      bool operator==(const Modint2_61 &a) const { return (x == a.x); }
      bool operator!=(const Modint2_61 &a) const { return (x != a.x); }
      bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map
      friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }
    };

    using mint = Modint2_61;
    const unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;
    struct RollingHash {
      vector<mint> hashed, power;
      int n;
      RollingHash(const string &s): n(ssize(s)) {
        hashed.assign(n + 1, 0);
        power.assign(n + 1, 0);
        power[0] = 1;
        for(ll i = 0; i < n; i++) {
          power[i + 1] = power[i] * base;
          hashed[i + 1] = hashed[i] * base + s[i];
        }
      }
      mint hash(ll l, ll r) const {
        return hashed[r] - hashed[l] * power[r - l];
      }
      static mint hash(const string &s) {
        mint r = 0;
        for(auto &i : s) { r = r * base + i; }
        return r;
      }
      mint connect(mint h1, mint h2, ll h2len) const {
        return h1 * power[h2len] + h2;
      }
      void connect(const string &s) {
        ll m = ssize(s);
        hashed.resize(n + m + 1);
        power.resize(n + m + 1);
        for(ll i = n; i < n + m; i++) {
          power[i + 1] = power[i] * base;
          hashed[i + 1] = hashed[i] * base + s[i - n];
        }
      }
      int find(string &s, int lhs = 0) const {
        mint h = hash(s);
        for(int i = lhs; i <= n - ssize(s); i++) {
          if(h == hash(i, i + ssize(s))) { return i; }
        }
        return -1;
      }
      ll LCP(const RollingHash &b, ll l1, ll r1, ll l2, ll r2) {
        ll len = min(r1 - l1, r2 - l2);
        ll low = -1, high = len + 1;
        while(high - low > 1) {
          ll mid = (low + high) / 2;
          if(hash(l1, l1 + mid) == b.hash(l2, l2 + mid)) { low = mid; }
          else { high = mid; }
        }
        return low;
      }
    };
    // https://github.com/tatyam-prime/kyopro_library/blob/master/RollingHash.cpp
    // https://nyaannyaan.github.io/library/string/rolling-hash.hpp (hash(string),find)
    """

  'Modint2_61':
    'prefix':'Modint2_61'
    'body':"""
    struct Modint2_61 {
      static constexpr unsigned long long MOD = (1ULL << 61) - 1;
      unsigned long long x;
      constexpr Modint2_61(): x(0ULL) {}
      constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }
      unsigned long long val() const noexcept { return x; }
      Modint2_61 operator-() const { return Modint2_61(MOD - x); }
      Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }
      Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }
      Modint2_61 operator*(const Modint2_61 &a) const {
        __uint128_t r = __uint128_t(x) * a.x;
        r = (r >> 61) + (r & MOD);
        return Modint2_61(r);
      }
      Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }
      Modint2_61 pow(ll n) const {
        if(n < 0) { return inv().pow(-n); }
        Modint2_61 r(1), t = *this;
        while(n) {
          if(n & 1) { r *= t; }
          t *= t;
          n >>= 1;
        }
        return r;
      }
      Modint2_61 inv() const { return pow(MOD - 2); }
      Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }
      Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }
      Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }
      Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }
      template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }
      template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }
      template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }
      template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }
      explicit operator bool() const { return x; }
      bool operator==(const Modint2_61 &a) const { return (x == a.x); }
      bool operator!=(const Modint2_61 &a) const { return (x != a.x); }
      bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map
      friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }
    };

    using mint=Modint2_61;
    const unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;
    """

  'gcd':
    'prefix':'gcd'
    'body':'gcd($1,$2)'

  'lcm':
    'prefix':'lcm'
    'body':'lcm($1,$2)'
